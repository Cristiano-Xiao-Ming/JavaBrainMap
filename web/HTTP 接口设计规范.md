# HTTP 接口设计规范

源自开源项目：https://github.com/flmn/http-api-demo

## 概述

### 基于 Java 的前后端分离开发，旨在要求一种 HTTP API 规范

## HTTP 协议

### HTTP 请求方法

- 所有请求使用 POST 方法
- 理由

	- 不遵循 RESTful 规范
	- 使用 POST，相对于 GET 的 Query String，可以支持复杂的请求参数，即使是读请求，可以构造复杂的筛选请求结构
	- 便于对请求和响应统一做签名、加密、日志等处理

### URL 规则

- URL 中只能包含英文，使用英文单词或简称，不要使用汉语拼音
- 所有字符使用小写字母
- 多个单词使用「-」分隔，如 create-user，不要使用 createuser、createUser 或者 create_user
- URL 的 path 部分，使用「系统/模块/操作」的格式，如 app/account/login

	- 系统：表示这个接口是给谁用的，比如：app、web、h5、webapp 等。命名可以使用简称
	- 模块：表示系统的子模块，比如：account（账户）、project（项目）、contract（合同）等。模块名字使用名词全称，且使用单数形式。
	- 操作：表示这个模块的具体的接口，比如 create-user（创建用户）、list-users（用户列表）等。使用动词 + 名词的形式，需要考虑复数。

### HTTP 头

- 将具体接口业务无关的数据放在 HTTP Headers
- 后端系统可以在不涉及请求和响应的情况下，处理一些公用逻辑

	- X-Access-Token：身份认证
	- X-App-OS：客户端 OS
	- X-App-Version：客户端版本
	- X-Network：客户端网络模式，Wi-Fi、蜂窝网络
	- X-Sign：请求签名

### 请求体和响应体

- 使用 UTF-8 编码
- JSON 格式
- 如果有加密功能，可以将正常的 JSON 加密后，使用 Base64 编码

### HTTP 状态码

- 业务的处理结果不体现在 HTTP 状态码，由响应体的错误码字段表示
- 只使用部分 HTTP 状态码来表示一些业务无关的响应

	- 200：业务已经处理，但是处理成功还是失败由响应体表示
	- 400：错误的请求，多用在请求验证，客户端开发要保证向服务器提交正确格式的请求，400 错误不该在生产环境出现
	- 401：认证失败，一般是没有 Acess Token 或者已经过期
	- 403：无权限，指没有权限调用这个接口，客户端应该在界面上将用户无权限的操作隐藏
	- 500：服务器发生了未处理的异常，500 错误不该在生产环境出现

## JSON（如何构造请求和响应体）

### 字段命名

- 由于 JSON 来自于 JS，所以字段命名遵循 JS 语言，采用驼峰写法（首字母小写），lowerCamelCase
- 不要采用 snake_case

### 数据类型

- 常用数据类型映射

	- bool：映射为 string，使用 Y 表示 true，N 表示 false
	- int：映射为 number
	- long：映射为 string
	- float、double、decimal：映射为 string
	- 日期、时间：映射为 string

- 特殊说明

	- 表示 ID 概念的字段，统一使用 string
	- long 映射为 string，是因为 JS 的 number 能处理的数值范围不够，导致各种奇怪的问题

### 空值处理

- 在数据传输时，如果某个字段是空值，则直接省略此字段不传，减少网络开销

### 嵌套 VS 平铺

- 嵌套优先级高于平铺，即 JSONObject 包含 JSONObject 、JSONArray 等结构，而不是一个 JSONObject  包含所有平级字段

### 响应体

- code：错误码，任何情况下必须返回
- message：错误信息，可选
- data：业务数据，可选，该字段最好是一个 Map
- errors：错误表，发生 HTTP 400 错误时，存在此字段，该字段最好是一个 Map，Key 为发生错误的请求字段，Value 为错误描述

### 错误码

- code 字段表示业务处理的错误码
- 如果业务处理成功，必须返回「成功的错误或标识」，比如「OK」或者标识成功的数字码
- 如果业务处理失败，使用不同的错误码区分不同的错误，错误码使用简短的能够体现错误种类的英文单词或者一串数字，英文的话使用大写字母，使用下划线分隔单词，建议使用英文单词。
- 数字错误码的劣势

	- 如果错误种类比较多，维护错误码表就是一个很大的工作
	- 数字错误码一般都是连续使用的，修改错误的定义是个麻烦事
	- 数字一眼很难辨识代表的是发生了什么错误

