# Java 的线程安全

## 类的状态角度看线程安全

原文地址：http://www.hyhblog.cn/2018/09/16/java_safe_concurrency/

### 类变量

- 公有变量（public）、私有变量（private）、保护变量（protect）
- 静态变量（static）
- 不可变变量（final）
- 外部变量、内部变量、局部变量

### Java 类的安全并发设计

- 无状态类（无任何成员变量声明）（多线程并发安全）
- 有状态类（Java 类中有成语变量声明）

	- 私有状态类（ThreadLocal）（多线程并发安全）
	- 共享状态类（类变量可以被多线程访问）

		- 不可变状态（final 常量）（多线程并发安全）
		- 可变状态

			- 静态状态（static）（多线程并发不不安全）
			- 非阻塞设计

				- 非阻塞算法（多线程并发安全）

					- 原子类（多线程并发安全）

			- 阻塞设计（加锁）（多线程并发安全）

				- 资源死锁（多线程并发不不安全）
				- 锁顺序死锁（多线程并发不不安全）
				- 状态公开（Publish）（多线程并发不不安全）

### Java 安全并发分解

- 无状态类

	- 一个无状态类是指其没有任何声明的成员变量，无状态类是线程安全的。

- 有状态类

	- 有状态类是指类中有声明的成员变量，有状态是导致线程不安全的必要条件，但不是充分条件

- 私有状态类

	- 如果 Java 类的状态通过 ThreadLocal 等方法，使得状态被隔离在各个线程中，相互不干扰

- 共享状态类

	- Java 成员变量是线程共享的，即多个线程通过 Java 类提供的类方法访问类对象时，类对象中的成员变量可以被共享访问到

- 不可变状态类（常量状态）

	- 变量被声明为 final，这说明这个变量是一个常量对象，初始化之后不再改变。
	- final 声明使得变量变为常量状态，多线程在访问时不能更改状态，在一定程度上实现了只读，从而是线程安全的。

- 可变状态类

	- 可变的共享状态，当多线程访问时，必然出现协同操作和同步问题，若代码设计不当，则很容易出现线程不安全问题。
	- 为了实现线程安全，一般通过「非阻塞设计（多线程并行执行，算法保证线程安全）」、「阻塞设计（加锁让多线程实现串行执行）」两种方法，

- 非阻塞设计

	- CAS 算法，即 Compare And Swap 方法，过程叫做 Compare And Set。

- 阻塞设计

	- 通过锁来控制线程对类状态的访问，使得当前状态只能由一个线程访问，其它访问线程则挂起等待，一直等到锁被释放后，所有的等待线程竞争锁，获得下一次访问权。
	- 若两个线程之间相互持有对方需要的资源或锁，则进入死锁状态。
	- 资源死锁

		- 资源不够多个线程调用，解决办法就是增加更多的资源。比如线程 1 获取了打印机，线程 2 获取了文件对象，相互都不是放锁，文件无法打印。

	- 锁顺序死锁

		- 线程 1 持有对象 A 的锁，线程 2 持有对象 B 的锁，而方法的执行需要 AB 同时交互执行，比如转账，导致锁顺序死锁
		- 实现锁的按序持有，即对于任何两个对象锁 A 和B，先进行排序，多线程都必须按照锁的排序依次获取，从而避免相互持有对方需要的锁。

	- 状态公开

		- 类成员变量被公开，在一定程度上破坏了面向对象设计的数据封装性。
		- 成员变量声明为私有，在执行读操作时，对外克隆一份数据副本，从而保证类内部数据对象不被泄露，

### 类的静态状态

- 类中被 static 声明的成员变量，这个状态会在类初次加载时初始化，被所有的类对象所共享。
- 若是 static 成员变量，必须考虑是否为 final。

### 类外部状态和多线程安全并发

- 类方法需要对外部传入的对象进行操作，外部状态的安全性取决于外部的并发设计。
- 在调用类方法的地方，传入一个外部状态的副本，隔离内外部数据的关联性。

## 线程安全的分类及方案

原文地址：https://www.cnblogs.com/duanxz/p/6099983.html

### 共享的数据（排除反射的干扰项）

- 不可变

	- final 关键字带来的可见性，只要一个不可变的对象被正确地构建出来（没有发生 this 引用逃逸的情况），那其外部的可见状态永远也不会改变
	- 如果共享数据是一个基本数据类型，那么只要在定义时使用 final 关键字修饰它就可以保证它是不可变的
	- 如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行

		- 保证对象行为不影响自己状态的途径有很多种，最简单的就是把对象中带有状态的变量都声明为 final

- 绝对线程安全

	- 在 Java API 中标注自己是线程安全的类，大多数都不是绝对的线程安全。
	- 可以理解为绝对的线程安全其实就是串行化了

- 相对线程安全

	- 我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施
	- 但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。

- 线程兼容

	- 对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用

- 线程对立

	- 无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。
	- Thread类的 suspend() 和 resume() 方法，已经过时

### 线程安全的一些方式

- 互斥同步，阻塞同步，锁同步

	- 同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用
	- 互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式
	- 最基本的互斥同步手段就是 synchronized 关键字
	- 还可以使用 J.U.C 包中的可重入锁 ReentrantLock 来实现同步，ReentrantLock增加了「等待可中断」、「可实现公平锁」、「锁可以绑定多个条件」等高级功能

		- 等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情
		- 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁，默认非公平锁
		- 锁绑定多个条件是指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象

	- 互斥同步最主要的问题是进行线程阻塞和唤醒所带来的性能问题，悲观的并发策略

- 非阻塞同步

	- 不需要把线程挂起的乐观并发策略
	- 先进行操作，如果没有其他线程争用共享数据即操作成功；
如果共享数据有争用，产生冲突，那就再采取补偿措施，常见的是不断地重试，直到成功为止）

- 无同步方案

	- 可重入性是更基本的特性，它可以保证线程安全

	  可重入代码（Reentrant Code）：这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。

	- 线程本地存储，可以通过 ThreadLocal 类来实现线程本地存储的功能

## 如何正确的停止（一个）线程

### 通过修改共享变量来通知目标线程停止运行

- 目标线程必须有规律的检查变量，当该变量指示它应该停止运行时，该线程应该按一定的顺序从它执行的方法中返回。
- 该变量必须定义为 volatile，或者所有对它的访问必须同步(synchronized)。

### 通过 Thread.interrupt 方法中断线程

- 该方法实际上只是设置了一个中断状态

	- 如果线程在调用 Object 类的 wait()、wait(long) 或 wait(long, int) 方法，或者该类的 join()、join(long)、join(long, int)、sleep(long) 或 sleep(long, int) 方法过程中受阻，则其中断状态将被清除，它还将收到一个InterruptedException异常。这个时候，我们可以通过捕获InterruptedException异常来终止线程的执行，具体可以通过return等退出或改变共享变量的值使其退出。
	- 如果该线程在可中断的通道上的 I/O 操作中受阻，则该通道将被关闭，该线程的中断状态将被设置并且该线程将收到一个 ClosedByInterruptException。这时候处理方法一样，只是捕获的异常不一样而已。

- Thread.currentThread().isInterrupted()

## Happen-Before 八大原则

### 单线程 happen-before 原则

- 在同一个线程中，书写在前面的操作 happen-before 后面的操作。

### 锁的 happen-before 原则

- 同一个锁的 unlock 操作 happen-before 此锁的 lock 操作。

### volatile 的 happen-before 原则

- 对一个 volatile 变量的写操作 happen-before对此变量的任意操作（也包括写操作）。

### happen-before 的传递性原则

- 如果 A 操作 happen-before B 操作，B 操作happen-before C 操作，那么 A 操作 happen-before C 操作。

### 线程启动的 happen-before 原则

- 同一个线程的 start 方法 happen-before 此线程的其它方法。

### 线程中断的 happen-before 原则

- 对线程 interrupt 方法的调用 happen-before 被中断线程的检测到中断发送的代码。

### 线程终结的 happen-before 原则

- 线程中的所有操作都 happen-before 线程的终止检测。

### 对象创建的 happen-before 原则

- 一个对象的初始化完成先于他的 finalize 方法调用。

