# 《码出高效》思维导图

## 计算机基础

### 子主题 1

### 子主题 1

### 子主题 1

### 子主题 1

### 子主题 1

### 子主题 1

### 子主题 1

## 面向对象

### 子主题 1

### 子主题 1

### 子主题 1

### 子主题 1

### 子主题 1

### 子主题 1

### 子主题 1

## 代码风格

### 命名规约

- 命名规约

	- 命名符合本语言特性
	- 命名体现代码元素特征

		- 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词
		- 抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类名开始，以 Test 结尾。
		- 类型与中括号紧挨相连来定义数组
		- 枚举类名带上 Enum 后缀，枚举成员名称需要全部大写，单词间用下划线隔开。

	- 命名最好忘文知义

- 常量

	- 定义

		- 作用域内保持不变的值，一般用 final 关键字进行修饰

	- 种类

		- 全局常量

			- 类的公开静态属性，public static final 修饰

		- 类内常量

			- 类的私有静态属性，private static final 修饰

		- 局部常量

			- 方法常量

				- 在方法或代码块内定义的常量

			- 参数常量

				- 定义形式参数时，增加 final 标识，标识此参数值不能被修改。

	- 常量规约

		- 字母全部大写，单词间加下划线，但是局部常量采用小驼峰形式即可。

- 变量

### 代码展示风格

- 缩进、空格与空行
- 换行与高度
- 控制语句

### 代码注释

- 注释三要素
- 注释格式

## 走进 JVM

### 子主题 1

### 子主题 1

### 子主题 1

### 子主题 1

### 子主题 1

## 异常与日志

### 子主题 1

### 子主题 1

### 子主题 1

### 子主题 1

## 代码规约

### 子主题 1

### 子主题 1

### 子主题 1

### 子主题 1

## 单元测试

### 子主题 1

### 子主题 1

### 子主题 1

## 并发与多线程

### 线程安全

- 并发

	- 指在某个时间段内，多任务交替处理的能力。
	- 并发的特点

		- 并发程序之间有相互制约的关系。
		- 并发程序的执行过程是断断续续的。
		- 当并发数设置合理并且 CPU 拥有足够的处理能力时，并发会提高程序的运行效率。

- 并行

	- 指同时处理多任务的能力。

- 线程是 CPU 调度和分派的基本单位

  线程可以拥有自己的操作栈、程序计数器、局部变量表等资源，它与同一进程内的其他线程共享该进程的所有资源。

- 多线程的优缺点

	- 提高任务的平均执行速度
	- 程序可理解性变差，编程难度加大

- 线程的生命周期

	- NEW（新建状态）：线程被创建旦未启动的状态。

		- 创建线程的三种方式（广度）

			- 继承自 Thread 类（不符合里式代换原则）

			  关于设计模式中的里式代换原则可以参考老四的《浅析设计模式第五章之依赖倒转原则》

			- 实现 Runnable 接口（推荐）
			- 实现 Callable 接口

				- V call() throws Exception
				- 可以通过 call() 获得返回值。前两者不能获取返回值，需要借助共享变量获取。
				- call() 可以抛出异常

		- 创建线程的七种方式（细分）

			- 继承 Thread 类

				- 创建多个线程
				- 指定线程名称

			- 实现 Runnable 接口

				- 创建线程任务
				- 创建可运行类
				- lambda 表达式方式创建线程任务

			- 使用内部类的方式
			- 定时器

				- 指定时间点执行
				- 间隔时间重复执行

			- 实现 Callable 接口
			- 基于线程池的方式
			- 使用 Spring 来实现多线程

				- @EnableAsync 和 @Async 注解

	- RUNNABLE（就绪状态）

		- 调用 start() 之后运行之前的状态

	- RUNNING（运行状态）

		- run() 正在执行时线程的状态

	- BLOCKED（阻塞状态）

		- 同步阻塞

			- 锁被其他线程占用

		- 主动阻塞

			- 调用 sleep()、join() 等方法主动让出 CPU 执行权

		- 等待阻塞

			- 执行了 wait()

	- DEAD（终止状态）

		- run() 执行结束，或者因为异常退出后的状态，不可逆转。

- 线程安全的维度考量（要么只读，要么加锁）

	- 数据单线程内可见

		- 单线程总是安全的
		- 线程局部变量，存储在独立虚拟机栈帧的局部变量表中，比如 ThreadLocal

	- 只读对象

		- 只读对象总是安全的，String、Integer 等
		- 只读对象的条件

			- 使用 final 关键字修饰，避免被继承
			- 使用 private final 关键字避免属性被中途修改
			- 没有任何更新方法
			- 返回值不能可变对象为引用

	- 线程安全类

		- 内部有非常明确的线程安全机制，比如 StringBuffer，采用 synchronized 关键字修饰相关方法

	- 同步与锁机制

- 并发包类族（java.util.concurrent）

	- 线程同步类

		- 逐步淘汰使用 Object 的 wait()、notify() 进行同步的方式
		- CountDownLatch、Semaphore、CyclicBarrier

	- 并发集合类

		- 由锁分段向 CAS 进化，并发性能不断提升
		- ConcurrentHashMap、ConcurrentSkipListMap、CopyOnWriteArrayList、BlockingQueue

	- 线程管理类

		- Thread、ThreadLocal
		- 线程池

	- 锁相关类

		- 以 Lock 接口为核心
		- ReentrantLock

### 什么是锁

- 锁的两种特性

	- 互斥性
	- 不可见性

- 计算机的锁

	- 悲观锁
	- 乐观锁
	- 偏向锁
	- 分段锁

- Java 中常用锁实现的方式

	- 并发包中的锁类（java.concurrent.locks），利用 volatile 的可见性

		- Lock
		- ReentrantLock

			- 作为 AQS 的子类，定义 state = 0 时可以获取资源并且置为 1。
			- 如果已经获得资源，state 不断加 1，在释放资源时 state 减 1，直至为 0。

		- AbstractQueuedSynchronizer，JUC 包实现同步的基础工具

			- 定义 volatile int state 变量作为共享资源，如果线程获取资源失败，就进入 FIFO 队列中等待
			- 如果成功获取资源就执行临界区代码
			- 执行完释放资源时，会通知同步队列中的等待线程来获取资源后出队并执行
			- 抽象类，内置自旋锁实现的同步队列，封装入队和出队的操作，提供独占、共享、中断等特性方法

		- CountDownLatch

			- 初始时定义资源总量 state = count，countDown() 不断将 state 减 1，当 state = 0 时才能获得锁，释放后 state 就一直为 0。
			- 所有线程调用 await() 都不会等待，CountDownLatch 是一次性的，用完后在想用就只能重新创建一个

		- CyclicBarrier

			- 与 CountDownLatch 不同的是 CyclicBarrier 可以循环使用
			- 基于 ReentrantLock 实现

		- Semaphore

			- 也定义了资源总量 state = permits，当 state > 0 时就能获得锁，并且将 state 减 1，当 state = 0 时只能等待其他线程释放锁
			- 当释放锁时 state 就加 1，其他等待线程又能获得这个锁
			- 当 permits = 1 时，就是互斥锁，当 permits > 1 就是共享锁

		- StampedLock

			- JDK8 新锁，改进了读写锁 ReentrantReadWriteLock

		- ReentrantReadWriteLock

	- 同步代码块（synchronized 关键字）

		- 使用方式

			- 方法签名处加 synchronized 关键字
			- 使用 synchronized(对象或类) 进行同步
			- 锁的范围尽可能小，时间尽可能短
			- 能锁对象就不要锁类，能锁代码块，就不要锁方法

		- 通过监视锁来实现 synchronized 同步
		- 监视锁

			- 每个对象与生俱来的一个隐藏字段
			- JVM 根据 synchronized 使用环境获取对应对象的监视锁，根据监视锁的状态进行加解锁的判断

		- synchronized 三种锁的实现

			- 偏向锁

				- 利用 CAS 在对象头上设置线程 ID，表示这个对象偏向于当前线程
				- 为了在资源没有被多线程竞争的情况下尽量减少锁带来的性能开销

			- 轻量级锁

				- 如果出现锁的竞争情况，偏向锁会被撤销并升级为轻量级锁

			- 重量级锁

				- 如果线程竞争情况激烈，就会升级为重量级锁

### 线程同步

### 线程池

- 线程池的好处

	- 线程池的作用

		- 利用线程池管理并复用线程、控制最大并发数等
		- 实现任务线程队列缓存策略和拒绝机制
		- 实现某些与时间相关的功能，如定时执行、周期执行等
		- 隔离线程环境

	- 线程池对线程的创建

		- ThreadPoolExecutor 构造

			- corePoolSize：常驻核心线程数
			- maximumPoolSize：线程池最大同时执行数
			- keepAliveTime：线程的空闲时间
			- unit：空闲时间单位（秒）
			- workQueue：缓存队列
			- threadFactory：线程工厂
			- handler：执行拒绝策略的对象

				- 友好的拒绝策略

					- 保存到数据库进行削峰填谷。在空闲时再提取出来执行
					- 转向某个提示页面
					- 打印日志

		-                     线程池相关类图

	- Executors 核心方法

		- newWorkStealingPool

		  JDK8 引入
		   创建持有足够线程的线程池支持给定的并行度，并通过使用多个队列减少竞争
		   CPU 数量会被设置为默认的并行度

		- newCachedThreadPool

		  高度可伸缩的线程池
		  工作线程处于空闲状态，则回收工作线程
		  如果任务数增加，再次创建出新线程处理任务

		- newScheduledThreadPool

		  定时及周期性任务执行
		  相比 Timer，ScheduledExecutorService 更安全，功能更强大
		  特点是不回收线程，而 newCachedThreadPool 回收工作线程

		- newSingleThreadExecutor

			- 创建一个单线程的线程池，相当于但线程串行执行所有任务，保证按任务的提交顺序依次执行

		- newFixedThreadPool

			- 固定线程数，既是核心线程数也是最大线程数，不存在空闲线程，所以 keepAliveTime 等于 0

- 线程池源码

	- 使用线程池的注意事项

		- 合理设置各类参数，应根据实际业务场景来设置合理的工作线程数。
		- 线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。
		- 创建线程或线程池时请指定有意义的线程名称，方便出错时回溯

	- ThreadPoolExecutor 源码

		- 四个公开的内部静态类

			- AbortPolicy

				- 丢弃任务并抛出 RejectedExecutionException 异常

			- DiscardPolicy

				- 丢弃任务，但是不抛出异常，不推荐

			- DiscardOldestPolicy

				- 抛弃队列中等待最久的任务，然后把当前任务加入队列中

			- CallerRunsPolicy

				- 调用任务的 run() 方法绕过线程池直接执行

		- 线程池状态定义（从小到大）

			- RUNNING（线程池可以接受新任务）
			- SHUTDOWN（不再接受新任务，但可以继续执行队列中的任务）
			- STOP（全面拒绝，并中断正在处理的任务）
			- TIDYING（所有任务已经被终止）
			- TERMINATED（已清理完现场）

### ThreadLocal

- 利弊

	- 初衷是在线程并发时，解决变量共享问题
	- 但是由于过度设计，导致了弱引用、哈希碰撞等一系列问题，使用成本高，理解难度大。

- 引用类型（引用力度逐级递减）

  首先你要知道对象存储在 JVM 的堆内存中，然后对象能否被回收的的基本条件是引用的可达性，也就是从 FC Roots 开始遍历，判断引用是否可达。

	- 强引用（相当于有房产证）

		- Object object =  new Object();
		- 只要对象有强引用指向，并且 GC Roots 可达，即使濒临内存耗尽，也不会回收对象

	- 软引用（相当于租房子住）

		- 主要用在非必需对象的场景，比如缓存服务器中间计算结果以及不需要实时保存的用户行为等。
		- 在即将 OOM 之前垃圾回收器会把这些软引用指向的对象加入回收范围

	- 弱引用（相当于被房产商给骗了，住了一阶段发现房子不属于自己的）

		- 调用 WeakReference.get() 可能会返回 null，注意 NPE
		- 如果弱引用只存在弱引用这一条线路，在下一次 Young GC 时会被回收
		- 也用来描述非必需对象，主要用于指向某个易消失的对象，典型应用在 WeakHaahMap 中。

	- 虚引用（相当于买房子直接被骗，钱花命没鸡飞蛋打）

		- 主要用来能在这个对象被回收时收到一个系统通知
		- 虚引用必须与引用队列联合使用。如果发现存在虚引用，就会在对象回收之前，把这个虚引用加入到相关引用队列当中

- ThreadLocal 价值

	- 将对象设置为共享变量，统一设置初始值，但是每个线程对这个值的修改都是互相独立的，这个对象就是 Threadocal
	- ThreadLocal 通常是由 private static 修饰的
	- ThreadLocal 无法解决共享对象的更新问题，所以使用某个引用来操作共享对象时，依然需要进行线程同步
	- ThreadLocal 有个内部静态类 ThreadLocalMap，ThreadLocalMap 也有一个内部静态类 Entry
	- ThreadLocalMap

		- 三个重要的方法

			- get()

				- 始终没有 get 操作的 ThreadLocal 对象是没有意义的

			- set()

				- 如果没有 set 操作的 ThreadLocal，容易引起脏数据问题

			- remove()

				- 如果没有 remove 操作，容易引起内存泄漏

		- Thread 中的 ThreadLocalMap 属性赋值是在 ThreadLocal 类中的 createMap() 中进行的

	- Entry

		- 继承自 WeakReference，没有方法，只有一个 value 成员变量
		- key 是 ThreadLocal 对象
		- ThreadLocal 的弱引用关系

			- 1 个 Thread 有且仅有 1 个 ThreadLocalMap 对象。
			- 1 个 Entry 对象的 key 弱引用指向 1 个 ThreadLocal 对象。
			- 1 个 ThreadLocalMap 对象存储多个 Entry 对象。
			- 1 个 ThreadLocal 对象可以被多个线程所共享。
			- ThreadLocal 对象不持有 Value，Value 由线程的 Entry 对象持有。

- ThreadLocal 副作用

	- 脏数据
	- 内存泄漏
	- 在每次用完 ThreadLocal 时，必须要及时调用 remove() 方法进行清理，脏数据的问题是要求你使用 set() 操作

## 数据结构与集合

### 数据结构

### 集合框架图

- List 集合

	- 线性数据结构的主要实现，最常用的就是 ArrayList 和 LinkedList
	- ArrayList 是容量可以改变的非线程安全集合，底层使用数组支撑，扩容是进行数据复制，查询块，插入删除慢。
	- LinkedList 本质是双向链表，同时因为实现 Deque，所以具有队列和栈的性质，可以将零散的内存单元通过引用的方式关联形成链路按照顺序查找。插入删除快而查询慢，内存利用率高。

- Queue 集合

	- 一种先进先出的数据结构，经常用作数据缓冲区
	- 最主要的是阻塞队列 BlockingDeque 接口的设计

		- SynchronousQueue
		- LinkedBlockingDeque
		- ArrayBlockingQueue
		- PriorityBlockingQueue
		- DelayQueue

- Map 集合

	- 最早用于存储键值对的 Hashtable 因为性能瓶颈已经被淘汰
	- HashMap 是线程不安全的
	- 并发环境下推荐使用 ConcurrentHashMap 线程安全的类
	- TreeMap 是 key 有序的键值对集合

- Set 集合

	- 不允许常出现重复元素的集合类型，最常用的有 HashSet、TreeSet、LinkedHashSet
	- HashSet 的底层使用的是 HashMap 来实现的，TreeSet 底层使用 TreeMap 来实现。
	- LinkedHashSet 直接继承 HashSet，内部使用链表维护元素的插入顺序

### 集合初始化

- ArrayList

	- 默认容量 10
	- 50% 扩容

- HashMap

	- 默认容量 16
	- 填充比例 0.75

### 数组与集合

### 集合与泛型

### 元素的比较

- Comparable 和 Comparator
- hashCode 和 equals

	- 两个方法协同工作用来判断两个对象是否相等
	- 对象相等判断的底层实现

		- 首先调用 Object.hashCode 生成哈希值
		- 如果哈希 hsahCode 不同，则对象肯定不同
		- 总是会存在哈希冲突的情况，此种情况需要使用 equals 方法做进一步判断

	- 如果两个对象的 equals 的结果是相等的，则两个对象的 hsahCode 的返回结果也必须是相同的。
	- 任何时候覆写 equals，都必须同时覆写 hashCode
	- 尽量避免通过实例对象引用来调用 equals 方法，否则容易抛出 NPE 空指针异常问题，推荐使用 Objects.equals

### fail-fast 机制

### Map 类集合
