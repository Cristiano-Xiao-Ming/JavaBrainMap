# JVM 杂记

## 类的加载

### 类的加载、连接、初始化

- 加载

  通过一个类的名字获取此类的二进制字节流，将这个字节流代表的静态存储结构转换为方法区的运行时结构，在内存中生成一个 java.lang.Class 对象，作为方法区这个类的各种数据结构的访问入口。

- 连接

	- 验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。
	- 准备：类准备阶段负责为类的类变量分配内存，并设置默认初始值。
	- 解析：将类的二进制数据中的符号引用替换成直接引用。

- 初始化：对类变量、静态初始块、类的结构块等进行初始化

  一、加入这个类还没有被加载和连接，则程序先加载并连接该类。
  二、假如该类的直接父类还没有被初始化，则先初始化其直接父类，依次往上进行初始化，所以 JVM 最先初始化的总是 java.lang.Object 类。
  三、假如类中有初始化语句,则系统一次执行这些初始化语句

### 类加载器

### 自定义类加载器

- 无法自定义一个叫 java.lang.System 的类

	- 会调用自定义类加载器的 loadClass 方法。
	- 我们自定义的 classLoader 必须继承 ClassLoader,loadClass 方法会调用父类的 defineClass 方法。
	- 父类的这个 defineClass 是一个 final 方法,无法被重写
	- 所以自定义的 classLoader 是无论如何也不可能加载到以 java. 开头的类的。

### JVM 进程终止

- 程序运行正常结束
- System.exit() 或者 Runtime.getRuntime().exit()
- 异常未捕获或者 error
- 强制结束 JVM 进程

## 内存模型

### JVM 内存区域划分、Java 运行时数据区

- 方法区（Method Area）

	- 运行时常量
	- 已被虚拟机加载的类信息
	- 静态变量
	- 即时编译器编译后的代码
	- 运行时常量池

- 堆（Heap）

	- 存放对象实例
	- 对象的创建

		- new 一个对象后，jvm 会先检查类是否已被加载，若未加载则先加载 ，否则在堆区创建该对象。
		- 对象在堆区的存储结构

			- 对象头

				- MarkWord

					- hashcode、gc 对象年龄、锁信息

				- Class Metadata Address

					- 指向对象类型数据的指针

				- Array Length

					- 数组长度

			- 实例数据
			- 填充数据

- 虚拟机栈（VM Stack）

	- 每个方法执行的同时都会创建一个栈帧，局部变量表、操作数栈、动态连接、返回地址等。
	- 存储局部变量表(boolean、byte、char、short、int、float、long、double、对象引用、returnAddress)
	- 方法出口
	- 每个方法从调用直至执行完成的过程，就对应这一个栈帧在虚拟机栈中入栈到出栈的过程。

- 本地方法栈（Native Method Stack）

	- 为虚拟机使用到的 Native 方法服务

- 程序计数器（Program Counter Register）

	- 唯一一个在 JVM 中没有规定任何 OutOfMemoryError 情况的区域
	- 通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线城恢复等基础功能都需要依赖程序计数器。

- 执行引擎
- 本地库接口
- 本地方法库

### JVM 内存模型

- Java 线程
- 工作内存
- Save 和 Load 操作
- 主内存
- voatile 关键字

	- 当这个变量的值被修改后，会立即刷新到主内存中，对其他线程可见；当某个线程读取这个变量的时候，也会重新将主内存中的数据刷一份到工作内存中来。保证可见性，但是不保证原子性
	- 禁止指令重排优化，也叫禁止指令重排序.观察voatile变量对应的字节码文件，会发现变量的操作指令后面加了一句lock addl $0x0,(%esp)的操作，这个操作相当于一个内存屏障。

- synchronized

	- 当一个线程对一个变量加锁的时候，就会清空这个变量在当前工作内存中的值，因此该关键字同时满足了可见性和原子性。

## 垃圾回收与内存分配

### 对象的存活

- 引用计数法，Java 虚拟机不采用

	- 基本定义：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。
	- 弊端：很难解决对象之间相互循环引用的问题

	  对象 objA 和 objB 都有字段 instance，赋值令 objA.instance=objB 及 objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为 0，于是引用计数算法无法通知GC收集器回收它们。

- 可达性分析法

	- 基本思路（图片可拖拽放大）

		- 是通过一系列的称为「GC Roots」的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（或者说从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。

	- Java 可作为 GC Roots 的对象

		- 虚拟机栈（栈帧中的本地变量表）中引用的对象
		- 方法区中类静态属性引用的对象
		- 方法区中常量引用的对象
		- 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象

- 引用

	- 基本定义

		- 如果 reference 引用类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，但是我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。所以在 JDK 1.2 之后重新设计了引用的概念。

	- 分类

		- 强引用（Strong Reference）

			- 在程序代码之中普遍存在的，类似「Object obj=new Object()」这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

		- 软引用（Soft Reference）

			- 用来描述一些还有用但并非必需的对象。

			  对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2  之后，提供了 SoftReference 类来实现软引用。

		- 弱引用（Weak Reference）

			- 也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。

		- 虚引用（Phantom Reference）

			- 也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。
			- 目的：在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类来实现虚引用。

### 回收算法（heap，堆内存的回收）

- 标记-清除算法（Mark-Sweep）

	- 首先标记所有需要回收的对象，在标记完成后统一回收所有被标记的对象。标记的方式：可达性分析。
	- 最基础的收集算法，后续所有的算法在此基础上改进而来。
	- 缺点一：效率不高，标记和清除的效率都不高。
	- 缺点二：产生大量的不连续内存碎片，导致程序运行过程中如果分配较大对象时，无法找到足够连续内存而触发垃圾收集动作。

- 复制算法（Copying）

	- 将可用内存按容量划分为大小相等的两快，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后已使用过的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收。
	- HotSpot 虚拟机将内存分为 1 个 Eden 和两个 Survivor 空间，比例 8:1 
	- 缺点：将内存玩的只剩下一半了，复制操作比较多，效率比较低。

- 标记-整理算法（Mark-Compact）

	- 就是标记之后不直接清除，而是让存活对象向一端移动，最后清理掉边界以外的内存。
	- 适合老年代使用

- 分代收集算法

	- 动态划分算法，根据对象的存活周期划分模块，根据对应的模块采取相应的回收算法。
	- 新生代：因为有大批量的对象死去，存活少量，所以一般采用复制回收算法。
	- 老年代：顾名思义就是对象寿命比较长，所以没有额外空间对其进行分配担保，一般采用「标记-清理」或者标记-整理算法
	- 永久代（Full GC）

		- 永久代是 Hotspot 虚拟机特有的概念，是方法区的一种实现，别的 JVM 都没有这个东西。在Java 8 中，永久代被彻底移除，取而代之的是另一块与堆不相连的本地内存-元空间。 

### 垃圾收集器

### 内存分配与回收策略

- Minor GC

	- 从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。
	- 每次 Minor GC 会清理年轻代的内存。

- Major GC

	- 清理老年代

- Full GC（Stop The World，全世界的暂停）

	- 清理整个堆空间—包括年轻代和老年代。
	- 清理永久代

		- 废弃常量
		- 无用类

			- 该类所所有的对象实例已经被回收，也就是 Java 堆中不存在该类的任何实例
			- 加载该类的 ClassLoader 已经被回收
			- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

		- 产生条件

		  频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久带不会溢出。

			- 大量使用反射
			- 动态代理（CGLib、JDK 动态代理）

	- 触发条件一、显式调用 System.gc() 方法
	- 触发条件二、大对象直接进入老年代，从年轻代晋升上来的老对象，尝试在老年代分配内存时，但是老年代内存空间不够；
	- 触发条件三、在执行 Young GC 之前，JVM 会进行空间分配担保——如果老年代的连续空间小于新生代对象的总大小，则触发一次 Full GC。

- Young GC

	- 清理年轻代
	- 触发条件：对象优先在新生代 Eden 区中分配，如果 Eden 区没有足够的空间时，就会触发一次 Young GC

## JVM 常用优化方案

参考美团技术团队，原文地址：
https://tech.meituan.com/2017/12/29/jvm-optimize.html

### 优化前的准备

- GC 优化需知

	- GC相关基础知识

		- GC 工作原理
		- 理解新生代、老年代、晋升等术语含义
		- 要看懂GC日志

	- GC 优化不能解决一切性能问题，它是最后的调优手段。

- JVM 基础回顾

	- JVM 内存结构

		- 分代回收，针对不同声明周期的对象采取不同的回收方式，提高回收效率
		- 新生代

			- 大多数对象在新生代中被创建，很对对象声明周期很短。每次 Minor GC 后只有少量对象存活，所以采用复制算法
			- 一个 Eden 区

				- 大部分对象在 Eden 区中生成，Eden 区满将依然存活的对象复制到两个 Survivor 区中的一个

			- 两个 Survivor 区

				- 当一个 Survivor 区满的时候，不满足晋升条件的对象会被复制到另一个 Survivor 区，满足晋升条件的会被放到老年代

			- 在 Serial 和 ParNew GC 回收期中，晋升年龄阈值通过参数「MaxTenuringThreshold」设定，默认值 15

		- 老年代

			- 在新生代中经历了 N 次垃圾回收仍然存活就回被放到老年代，此区域对象存活率高
			- 老年代的垃圾回收叫做「Major GC」，通常使用「标记-整理」、「标记-清除」算法
			- 新生代和老年代一起回收也就是整个堆回收叫做「Full GC」

	- 常见垃圾回收器

		- Serial 串行回收器

			- 单线程回收器，简单、易实现、效率高

		- ParNew 并行回收器

			- Serial 的多线程版本，可以充分利用 CPU 资源，减少回收时间

		- Parallel Scavenge 吞吐量优先回收器

			- 侧重于吞吐量的控制，吞吐量 = 运行业务代码的时间/(运行业务代码的时间+垃圾回收时间)

		- CMS 并发标记清除回收器

			- 以获取最短回收停顿时间为目标的回收器，基于「标记-清除」算法实现

		- G1 回收器

			- 对分区为一个个相同的「region」的可预测暂停时间的垃圾回收器

	- GC日志

- 参数基本策略

	- 活跃数据的大小

		- 应用程序稳定运行时长期存活对象在堆中占用的空间大小，也就是 Full GC 后堆中老年代占用空间的大小

	- 以活跃大小为 300M 为例

		- 总堆：300 * 4 = 1200M
		- 新生代：300 * 1.5 = 450M
		- 老年代：1200 - 450 = 750M

### 优化步骤

- 确定目标

	- 高可用：可用性达到几个 9
	- 低延迟：请求必须多少毫秒内完成响应
	- 高吞吐：每秒完成多少次事务

- 优化参数

	- 合适的 GC 回收器
	- 重新设置内存比例
	- 调整 JVM 参数

- 验收结果

### GC 优化案例（垃圾回收器均为 ParNew + CMS，CMS 失败时 Serial Old 替补）

- Major GC和 Minor GC频繁

	- Minor GC频繁通常由于新生代空间较小，Eden 区很快被填满，导致频繁 Minor GC，可以通过增大新生代空间来降低 Minor GC 的频率
	- 单次 Minor GC 时间更多取决于 GC 后存活对象的数量，而非 Eden 区的大小。
	- 扩容新生代空间后，Minor GC 频率降低，对象在新生代得到充分回收，只有生命周期长的对象才进入老年代。这样老年代增速变慢，Major GC 频率自然也会降低。
	- 根据对象生命周期的分布情况

		- 如果应用存在大量的短期对象，应该选择较大的年轻代；
		- 如果存在相对较多的持久对象，老年代应该适当增大。

	- 动态年龄计算

		- Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 Survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值。

- 请求高峰期发生 GC，导致服务可用性下降

	- CMS 四个主要阶段

		- 初始标记

			- 进行可达性分析，标记 GC Roots 能直接关联到的对象

		- 并发标记

			- 初始标记过得对象重新出发，再次进行标记

		- 重新标记

			- Stop The World，重新进行可达性分析

		- 并发清理

			- 进行并发的垃圾清理

	- 新生代 GC 和老年代的 GC 是各自分开独立进行的
	- CMS 为了避免这个阶段没有等到 Minor GC 而陷入无限等待，提供了参数「CMSMaxAbortablePrecleanTime」，默认为 5s，含义是如果可中断的预清理执行超过5s，不管发没发生 Minor GC，都会中止此阶段，进入重新标记阶段。
	- CMS 提供 CMSScavengeBeforeRemark 参数，用来保证重新标记阶段之前强制进行一次 Minor GC。

- 发生 Stop The World 的 GC

	- 触发 Full GC 的可能情况

		- 元空间内存不足
		- CMS GC 时出现 promotion failed 和concurrent mode failure
		-  统计得到的 Young GC 晋升到老年代的平均大小大于老年代的剩余空间
		- 主动触发 Full GC 来避免内存空间碎片问题

	- 启动时将元空间大小固定，避免进行动态扩容。
	- JDK8 及以上版本，已经移除了永久代的概念，字符串常量已经移至到堆内存中，其余内容如类元信息、字段、静态属性、方法、常量等放入堆空间中。区别于永久代，元空间在本地内存中进行分配。

### 总结

- 进行 GC 优化之前，需要确认项目的架构和代码等已经没有优化空间
- 不要为了调优而调优，不当的调优可能适得其反

