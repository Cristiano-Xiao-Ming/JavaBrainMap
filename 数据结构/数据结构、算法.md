# 数据结构、算法

## 算法概述

## 数据结构基础

### 数组（Array）

- 定义

	- 有限个相同类型的变量所组成的有序集合

- 特点

	- 顺序存储，在内存中占用了连续完整的存储空间
	- 有限，并且数组的实际元素有可能小于数组的长度
	- 元素类型相同

- 基本操作

	- 增

		- 尾部插入

			- 直接放到尾部即可（在存储空间还有空余的情形），也相当于一个更新操作。

		- 中间插入

			- 先把插入位置及后面的元素向后移动，再在对应位置插入要插入的元素。

		- 超范围插入

			- 数组扩容

				- 时间复杂度：O(n)

			- 尾部插入或者中间插入

		- 时间复杂度：O(n)

	- 删

		- 中间删除的话，删除元素后面的元素需要向前移动
		- 时间复杂度：O(n)
		- 投机取巧的方式：将数组最后元素赋值给要被删除的元素，再讲最后一个元素删除，这样会改变数组的顺序，但是删除的时间复杂度变成 O(n)。

	- 改

		- 利用数组下标直接更新某个元素的值
		- 时间复杂度：O(1)

	- 查

		- 下标读取，从 0 开始计数，称为「随机读取」
		- 时间复杂度：O(1)

- 适用场景，与链表的区别

	- 快速定位元素
	- 读多写少

### 链表（Linked List）

- 定义

	- 物理上非连续、非顺序的数据结构，由若干节点（Node）组成。
	- 节点（单向）

		- 存放数据的变量 data
		- 指向下一个节点的指针 next
		- 第一个节点称为「头节点」
		- 最后一个节点称为「尾节点」

- 特点

	- 随机存储，见缝插针，每一个节点分布在内存的不同位置。
	- 无限，只要内存足够，不考虑扩容问题

- 单向链表

	- 增

		- 尾部插入

			- 最后一个节点的 next 指针指向新插入的节点

		- 头部插入

			- 把新节点的 next 指针指向原先的头节点
			- 把新节点变成链表的头节点

		- 中间插入

			- 把新节点的 next 指针指向插入位置的节点
			- 插入位置的前置节点的 next 指针指向新插入的节点

		- 时间复杂度：O(1)

	- 删

		- 尾部删除

			- 把倒数第二个节点的 next 指针指向 NULL

		- 头部删除

			- 第二个节点设置为头节点

		- 中间删除

			- 删除节点的前置节点的 next 指针指向删除节点的下一个节点

		- 时间复杂度：O(1)

	- 改

		- 直接替换节点 data 的值即可
		- 时间复杂度：O(1)

	- 查（逐一查找）

		- 指针定位头节点
		- 根据头节点 next 指针找到第二个节点
		- 根据第二个节点的 next 指针循环的找下去，直到找到。
		- 时间复杂度：O(n)

- 双向链表

	- 相别于单向链表，节点多了一个指向前置节点的 prev 指针

- 适用场景，与数组的区别

	- 灵活地进行插入、删除操作
	- 写多读少

### 栈和队列

### 散列表

## 树

### 树的一些基本概念

- 定义

	- n 个节点的有限集，有且仅有一个特定的称为根的节点。当 n > 1 时，其余节点可分为 m 个互不相交的有限集，每一个集合又是一个树，称为根的子树。

- 树的路径

	- 概念

		- 从一个节点到另一个节点所经过的所有节点就是两个节点直接的路径

	- 路径长度

		- 从一个节点到另一个节点所经过的「边」的数量

	- 节点的带权路径长度

		- 树的根节点到该节点的路径长度 × 该节点的权重值

	- 树的带权路径长度

		- 所有叶子节点的带权路径长度之和，简称「WPL」

### 二叉树

- 物理存储方式

	- 链式存储

		- 存储数据的 data 变量
		- 指向左孩子的 left 指针
		- 指向右孩子的 right 指针

	- 数组

		- 按照层级顺序吧二叉树的节点放到数组中对应的位置上。如果某个节点的左孩子或者右孩子为空，数组对应的位置也留空
		- 父节点的下标如果是 P

			- 左孩子节点下标：2 * P + 1
			- 右孩子节点下标：2 * P + 2

		- 二叉堆使用数组形式存储完全二叉树

- 二叉树的遍历

	- 深度优先遍历

		- 前序遍历

			- 输出顺序是「根节点、左子树、右子树」

		- 中序遍历

			- 首先访问根节点的左孩子，如果左孩子还拥有左孩子，继续深入访问下去，知道找不到再有左孩子节点，输出该节点
			- 输出顺序是「左子树、父节点、右子树」

		- 后序遍历

			- 输出顺序是「左子树、右子树、根节点」

	- 广度优先遍历

		- 层序遍历

- 满二叉树

	- 一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上

- 完全二叉树

	- 对一个有 N 个节点的二叉树，按照层级顺序编号，则所有节点的编号为从 1 到 N。如果这个数所有 节点和同样深度的满二叉树的编号为从 1 到 n 的节点位置相同，则这个二叉树为完全二叉树

- 哈夫曼树、最优二叉树

	- 叶子节点和权重确定的情况下，带权路径长度最小的二叉树
	- 构建步骤

		- 构建森林

			- 把每个叶子节点当做独立的只有根节点的树，形成一个森林，按照权重从小到大按照队列展示

		- 选择权重最小的两个节点，生成新的根节点（权重相加）
		- 删除已构建的节点，将新的根节点加入到队列
		- 再次选择两个权重最小的节点生成新的父节点
		- 重复依照上述进行构建，最后去除掉两两节点相加的父节点权重节点，就是一颗哈夫曼树

- 二叉树的应用

	- 二叉查找树

		- 定义及限制条件

			- 如果左子树不为空，则左子树上所有节点的值均小于根节点的值
			- 如果右子树不为空，则右子树上所有节点的值均大于根节点的值
			- 左、右子树也都是二叉查找树

		- 自平衡

			- 红黑树

				- 解决二叉查找树多次插入导致的不平衡
				- 特点

					- 节点是红色或黑色。
					- 根节点是黑色。
					- 每个叶子节点都是黑色的空节点（NIL节点）。
					- 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
					- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

				- 调整

					- 变色
					- 旋转

						- 左旋转
						- 右旋转

			- AVL 树
			- 树堆

	- 二叉排序树

### 二叉堆

- 最大堆

	- 任何一个父节点的值都大于等于左右节点的值
	- 最大堆的堆顶是整个堆中的最大元素

- 最小堆

	- 任何一个父节点的值小于等于左右孩子节点的值
	- 最小堆的堆顶是整个堆中的最小元素

- 二叉堆的自我调整

	- 插入节点

		- 完全二叉树的最后一个位置插入，在逐层比较

	- 删除节点

		- 删除处于堆顶的节点
		- 完全二叉树的最后一个节点补位到堆顶

	- 构建二叉堆

		- 从最后一个非叶子节点轮询调整

- 优先队列

	- 最大优先队列

		- 无论入队顺序如何，都是当前最大的元素优先出队

	- 最小优先队列

		- 无论入队顺序如何，都是当前最小的元素优先出队

## 算法的实际应用

## 面试中的算法

## 排序算法

