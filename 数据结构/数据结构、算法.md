# 数据结构、算法

## 算法概述

## 数据结构基础

### 数组（Array）

- 定义

	- 有限个相同类型的变量所组成的有序集合

- 特点

	- 顺序存储，在内存中占用了连续完整的存储空间
	- 有限，并且数组的实际元素有可能小于数组的长度
	- 元素类型相同

- 基本操作

	- 增

		- 尾部插入

			- 直接放到尾部即可（在存储空间还有空余的情形），也相当于一个更新操作。

		- 中间插入

			- 先把插入位置及后面的元素向后移动，再在对应位置插入要插入的元素。

		- 超范围插入

			- 数组扩容

				- 时间复杂度：O(n)

			- 尾部插入或者中间插入

		- 时间复杂度：O(n)

	- 删

		- 中间删除的话，删除元素后面的元素需要向前移动
		- 时间复杂度：O(n)
		- 投机取巧的方式：将数组最后元素赋值给要被删除的元素，再讲最后一个元素删除，这样会改变数组的顺序，但是删除的时间复杂度变成 O(n)。

	- 改

		- 利用数组下标直接更新某个元素的值
		- 时间复杂度：O(1)

	- 查

		- 下标读取，从 0 开始计数，称为「随机读取」
		- 时间复杂度：O(1)

- 适用场景，与链表的区别

	- 快速定位元素
	- 读多写少

### 链表（Linked List）

- 定义

	- 物理上非连续、非顺序的数据结构，由若干节点（Node）组成。
	- 节点（单向）

		- 存放数据的变量 data
		- 指向下一个节点的指针 next
		- 第一个节点称为「头节点」
		- 最后一个节点称为「尾节点」

- 特点

	- 随机存储，见缝插针，每一个节点分布在内存的不同位置。
	- 无限，只要内存足够，不考虑扩容问题

- 单向链表

	- 增

		- 尾部插入

			- 最后一个节点的 next 指针指向新插入的节点

		- 头部插入

			- 把新节点的 next 指针指向原先的头节点
			- 把新节点变成链表的头节点

		- 中间插入

			- 把新节点的 next 指针指向插入位置的节点
			- 插入位置的前置节点的 next 指针指向新插入的节点

		- 时间复杂度：O(1)

	- 删

		- 尾部删除

			- 把倒数第二个节点的 next 指针指向 NULL

		- 头部删除

			- 第二个节点设置为头节点

		- 中间删除

			- 删除节点的前置节点的 next 指针指向删除节点的下一个节点

		- 时间复杂度：O(1)

	- 改

		- 直接替换节点 data 的值即可
		- 时间复杂度：O(1)

	- 查（逐一查找）

		- 指针定位头节点
		- 根据头节点 next 指针找到第二个节点
		- 根据第二个节点的 next 指针循环的找下去，直到找到。
		- 时间复杂度：O(n)

- 双向链表

	- 相别于单向链表，节点多了一个指向前置节点的 prev 指针

- 适用场景，与数组的区别

	- 灵活地进行插入、删除操作
	- 写多读少

### 栈和队列

### 散列表

## 树

### 树的一些基本概念

- 定义

	- n 个节点的有限集，有且仅有一个特定的称为根的节点。当 n > 1 时，其余节点可分为 m 个互不相交的有限集，每一个集合又是一个树，称为根的子树。

- 树的路径

	- 概念

		- 从一个节点到另一个节点所经过的所有节点就是两个节点直接的路径

	- 路径长度

		- 从一个节点到另一个节点所经过的「边」的数量

	- 节点的带权路径长度

		- 树的根节点到该节点的路径长度 × 该节点的权重值

	- 树的带权路径长度

		- 所有叶子节点的带权路径长度之和，简称「WPL」

### 二叉树

- 物理存储方式

	- 链式存储

		- 存储数据的 data 变量
		- 指向左孩子的 left 指针
		- 指向右孩子的 right 指针

	- 数组

		- 按照层级顺序吧二叉树的节点放到数组中对应的位置上。如果某个节点的左孩子或者右孩子为空，数组对应的位置也留空
		- 父节点的下标如果是 P

			- 左孩子节点下标：2 * P + 1
			- 右孩子节点下标：2 * P + 2

		- 二叉堆使用数组形式存储完全二叉树

- 二叉树的遍历

	- 深度优先遍历

		- 前序遍历

			- 输出顺序是「根节点、左子树、右子树」

		- 中序遍历

			- 首先访问根节点的左孩子，如果左孩子还拥有左孩子，继续深入访问下去，知道找不到再有左孩子节点，输出该节点
			- 输出顺序是「左子树、父节点、右子树」

		- 后序遍历

			- 输出顺序是「左子树、右子树、根节点」

	- 广度优先遍历

		- 层序遍历

- 满二叉树

	- 一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上

- 完全二叉树

	- 对一个有 N 个节点的二叉树，按照层级顺序编号，则所有节点的编号为从 1 到 N。如果这个数所有 节点和同样深度的满二叉树的编号为从 1 到 n 的节点位置相同，则这个二叉树为完全二叉树

- 哈夫曼树、最优二叉树

	- 叶子节点和权重确定的情况下，带权路径长度最小的二叉树
	- 构建步骤

		- 构建森林

			- 把每个叶子节点当做独立的只有根节点的树，形成一个森林，按照权重从小到大按照队列展示

		- 选择权重最小的两个节点，生成新的根节点（权重相加）
		- 删除已构建的节点，将新的根节点加入到队列
		- 再次选择两个权重最小的节点生成新的父节点
		- 重复依照上述进行构建，最后去除掉两两节点相加的父节点权重节点，就是一颗哈夫曼树

- 二叉树的应用

	- 二叉查找树

		- 定义及限制条件

			- 如果左子树不为空，则左子树上所有节点的值均小于根节点的值
			- 如果右子树不为空，则右子树上所有节点的值均大于根节点的值
			- 左、右子树也都是二叉查找树

		- 自平衡

			- 红黑树

				- 解决二叉查找树多次插入导致的不平衡
				- 特点

					- 节点是红色或黑色。
					- 根节点是黑色。
					- 每个叶子节点都是黑色的空节点（NIL节点）。
					- 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
					- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

				- 调整

					- 变色
					- 旋转

						- 左旋转
						- 右旋转

			- AVL 树
			- 树堆

	- 二叉排序树

### 二叉堆

- 最大堆

	- 任何一个父节点的值都大于等于左右节点的值
	- 最大堆的堆顶是整个堆中的最大元素

- 最小堆

	- 任何一个父节点的值小于等于左右孩子节点的值
	- 最小堆的堆顶是整个堆中的最小元素

- 二叉堆的自我调整

	- 插入节点

		- 完全二叉树的最后一个位置插入，在逐层比较

	- 删除节点

		- 删除处于堆顶的节点
		- 完全二叉树的最后一个节点补位到堆顶

	- 构建二叉堆

		- 从最后一个非叶子节点轮询调整

- 优先队列

	- 最大优先队列

		- 无论入队顺序如何，都是当前最大的元素优先出队

	- 最小优先队列

		- 无论入队顺序如何，都是当前最小的元素优先出队

## 算法的实际应用

## 面试中的算法

## 排序算法

## 图

### 定义

- 图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G (V, E），其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。

	- 数据元素叫做「顶点」
	- 在图结构中，不允许没有顶点
	- 任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以为空。

### 各种图定义

- 无向边

	- 顶点 Vi 到 Vj 之间的边没有方向，用无序偶对 (Vi, Vj) 来表示

- 无向图

	- 图中任意两个顶点之间的边都是无向边

- 有向边

	- 顶点 Vi 到 Vj 之间的边有方向，也称为弧，用有序偶对 <Vi, Vj> 表示，Vi 称为弧尾（Tail），Vj 称为弧头（Head）。

- 有向图

	- 图中任意两个顶点之间的边都是有向边

- 简单图

	- 不存在顶点到其自身的边，且同一条边不重复出现

- 无向完全图

	- 在无向图中，任意两个顶点之间都存在边

		- n 个顶点的无向完全图有 n * (n - 1) / 2 条边

- 有向完全图

	- 在有向图中，任意两个顶点之间都存在方向互为相反的两条弧

		- n 个顶点的无向完全图有 n * (n - 1) 条边

- 稀疏图、稠密图

	- 相对而言，以边的数量为目的

- 权

	- 有些图的边或弧具有与它相关的数字，可以表示从一个顶点到另一个顶点的距离或耗费

- 网

	- 带权的图

- 子图

	- 假设有两个图 G = (V, {E}) 和 G' = (V', {E'})，如果 V' 是 V 的子集且 E' 是 E 的子集，那么 G' 就是 G 的子图

### 图的顶点与边

- 互为邻接点

	- 对于无向图

- 顶点的度

	- 与当前顶点相关联的边的数目，记为 TD
	- 对于无向图，边数 = 给顶点度数和的一半

- 对于有向图，邻接到顶点或者叫做邻接自顶点
- 有向图的入度、出度

	- 以顶点 V 为头的弧的数目叫入度（ID）
	- 以 V 为尾的弧的数目称为 V 的出度（OD）
	- 对于有向图，顶点 V 的度为 TD = ID + OD
	- 对于有向图，边数 = ID = OD

- 顶点序列

	- 对于无向图，从顶点 V 到顶点 V' 的路径
	- 对于有向图，要满足 <Vi,j-1, Vi,j> 是 E 的子集
	- 路径长度

		- 路径上的边或弧的数目

- 回路或环

	- 第一个顶点到最后一个顶点相同的路径
	- 简单路径、简单环

		- 除了第一个顶点he最后一个顶点之外，其余顶点不重复出现

### 连通图相关术语

- 连通图

	- 对于无向图，图中任意两个顶点 Vi,Vj，Vi 和 Vj 都是连通的，就是连通图

- 连通分量

	- 无向图中的极大连通子图

		- 要是子图
		- 子图要是连通的
		- 连通子徒含有极大顶点数
		- 具有极大顶点数的连通子图包含依附于这些顶点的所有边

- 强连通图

	- 对于有向图，图中任意两个顶点 Vi,Vj，Vi 到 Vj 和 Vj 到 Vi 都存在路径，就是强连通图

- 强连通分量

	- 有向图中的极大强连通子图

- 生成树

	- 一个极小的连通子图，他含有图中全部的 n 个顶点，但只有足以构成一棵树的 n - 1 条边。

- 有向树

	- 恰好有一个顶点的入度为 0，其余顶点的入度均为 1。

### 图的抽象数据类型

- Data

	- 顶点的有穷非空集合和边的集合

- Operation

	- CreateGraph

		- 按照顶点集 V 和边弧集 VR 的定义构造图 G

	- DestroyGraph

		- 图 G 存在则销毁

	- LocateVex

		- 若图 G 中存在顶点 u，则返回图中的位置

	- GetVex

		- 返回图 G 中顶点 V 的值

	- PutVex

		- 将图 G 中顶点 v 赋值 value

	- FirstAdjVex

		- 返回顶点 v 的一个邻接顶点，若顶点在 G 中无邻接顶点返回空

	- NextAdjVex

		- 返回顶点 v 相对于顶点 w 的下一个邻接点，若 w 是 v 的最后一个邻接点则返回「空」

	- InsertVex

		- 在图 G 中增添新顶点 v 及其相关的弧

	- DeleteVex

		- 删除图 G 中顶点 v 及其相关的弧

	- InsertArc

		- 在图 G 中增添弧 <v, w>，若 G 是无向图，还需要增添对称弧 <w, v>

	- DeleteArc

		- 在图 G 中删除弧 <v, w>，若 G 是无向图，则还删除对称弧 <w, v>。

	- DFSTraverse

		- 对图 G 中进行深度优先遍历，在遍历过程对每个顶点调用

	- HFSTraverse

		- 对图 G 中进行广度优先遍历，在遍历过程对每个顶点调用

### 图的存储结构

- 五种不同的存储结构

	- 邻接矩阵

		- 两个数组来表示图

			- 一维数组存储图中顶点信息
			- 二维数组（称为邻接矩阵）存储图中的边或弧的信息

	- 邻接表

		- 数组与链表相结合的存储方法

	- 十字链表

		- 对于有向图，把邻接表与逆邻接表结合起来

	- 邻接多重表
	- 边集数组

		- 两个一维数组

			- 一个存储顶点的信息
			- 一个存储边的信息，每个数据元素由一条边的起点下标（begin）、终点下标（end）和权（wight）组成

### 图的遍历

- 定义

	- 图中某一顶点触发访遍图中其余顶点，且使没一个顶点仅被访问一次

- 深度优先遍历、深度优先搜索（DFS）

	- 树的前序遍历

- 广度优先遍历、广度优先搜索（BFS）

	- 树的层序遍历

### 最小生成树

- 构造连通网的最小代价生成树称为最小生成树
- 普里姆（Prim）算法
- 克鲁斯卡尔（Kruskal）算法

### 最短路径

- 定义

	- 对于非网图，指两顶点之间经过的边数最少的路径
	- 对于网图，指两顶点之间经过的边上权值之和最少的路径，路径上的第一个顶点是源点，最后一个顶点是终点

- 地杰斯特拉（Dijkstra）算法
- 弗洛伊德（Floyd）算法

### 拓扑排序

- AOV 网

	- 在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系

- 拓扑序列
- 定义

	- 对一个有向图构造拓扑序列的过程

- 拓扑排序算法

### 关键路径

- AOE 网

	- 在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间

- 路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动

