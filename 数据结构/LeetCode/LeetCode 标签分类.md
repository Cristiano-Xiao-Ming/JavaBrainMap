# LeetCode 标签分类

## 队列

## 极小化最大

## 蓄水池抽样

## 几何

## Map

## 数组

### 题目列表

- 56.合并区间
- 78.子集

## 哈希表

## 链表

### 题目列表

- 23.合并K个排序链表

### 题目类型

- 链表的合并

## 数学

## 双指针

## 字符串

### 分类

- 子序列

	- 不一定是连续的

- 子串

	- 一定是连续的

### 题目列表

- 44.通配符匹配

## 二分查找

### 关键点

- 二分查找真正的坑在于到底要给 mid 加一还是减一，while 里到底用 <= 还是 <。
- 分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。
- int mid = left + (right - left) / 2;

### 分类 [1,2,2,2,3]

- 无边界二分查找
- 左侧边界二分查找
- 右侧边界二分查找

### 题目列表

- 74.搜索二维矩阵
- 95.96.不同的二叉搜索树
- 240.搜索二维矩阵 II
- 300.字符串最长上升子序列
- 927.三等分

## 分治算法

### 23.合并K个排序链表

### 分治就是不断缩小其规模，再不断合并扩大的过程

## 动态规划

### 动态规划问题的⼀般形式就是求最值

- 最⻓递增⼦序列
- 最⼩编辑距离

### 求解动态规划的核⼼问题是穷举、核心设计思想是数学归纳法


- 存在「重叠⼦问题」,暴⼒穷举的话效率会极其低下
- 优化穷举

	- 「备忘录」

		- 每次算出某个子问题的答案后不返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经存在泽直接把答案拿出来。
		- 一般使用数组、哈希表（字典）实现备忘录
		- 自顶向下

	- 「DP table」

		- 动态规划⼀般都脱离了递归，⽽是由循环迭代完成计算。（自底向上）
		- 把「备忘录」独⽴出来成为⼀张表，叫 DP table ，在这张表上完成「⾃底向上」的推算
		- 遍历

			- 正向遍历
			- 反向遍历
			- 斜向遍历

	- 动态规划问题⼀定会具备「最优⼦结构」，才能通过⼦问题的最值得到原问题的最值。
	- 只有列出正确的「状态转移⽅程」才能正确地穷举。

### 动态规划三要素

- 重叠子问题
- 最优子结构

	- 要符合「最优⼦结构」，⼦问题间必须互相独⽴。

- 状态转移方程（最难）

### 解题思维框架

- 明确「状态」、明确「选择」
-  定义 dp 数组/函数的含义
- 明确 base case
- 代码模板

	- 

### 题目列表

- 44.通配符匹配
- 518.零钱兑换 II

## 回溯算法

### 题目列表

- 44.通配符匹配
- 78.子集

### 回溯算法关键在于:不合适就退回上一步

## 随机

## Rejection Sampling

## Sliding Window

## Ordered Map

## Line Sweep

## 记忆化

## 脑筋急转弯

## 递归

### 递归算法的时间复杂度

- ⼦问题个数乘以解决⼀个⼦问题需要的时间。

### 记忆递归

- 优化递归的标准方法。创建一个记忆的哈希映射。将所有已经检查的 (s, p) 保留在哈希映射中。这样，如果有任何重复的检查，只需查看哈希表，而不需再次进行计算。

## 二叉搜索树

## 线段树

## 树状数组

## 字典树

## 拓扑排序

## 设计

## 图

## 并查集

## 广度优先搜索

## 深度优先搜索

## 树

## 位运算

### 题目列表

- 78.子集

## 排序

### 分类

- 耐心排序

### 题目列表

- 56.合并区间
- 300.字符串最长上升子序列

## 贪心算法

### 题目列表

- 44.通配符匹配

## 堆

### 题目列表

- 23.合并K个排序链表

### 最大堆、最小堆，在 Java 中 PriorityQueue 就是其的实现

### 关于 Comparator ：如果 return 的大于 0 则前一位排在后一位的后面即升序，如果 return 的小于 0 则前一位排在后一位的的前面，为降序

## 栈

### 题目列表

- 20.有效的括号

### 在表示问题的递归结构时，栈数据结构可以派上用场。

