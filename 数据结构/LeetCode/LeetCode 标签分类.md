# LeetCode 标签分类

## 队列

### 队列是一种与栈相反的 先进先出（first in - first out， FIFO）的数据结构，队列中元素只能从 后端（rear）入队（push），然后从 前端（front）端出队（pop）

## 极小化最大

## 蓄水池抽样

## 几何

## Map

## 数组

### 题目列表

- 1.两数之和
- 48.旋转图像
- 56.合并区间
- 78.子集

### 矩阵转置

- 把 m×n 矩阵 A 的行换成同序数的列得到一个 n×m 矩阵，此矩阵叫做 A 的转置矩阵

## 哈希表

### 题目列表

- 3.无重复字符的最长子串

### 哈希表的底层就是数组；

### 哈希函数；

### 哈希冲突的解决办法

- 链接法
- 开放地址法
- 哈希表的扩容

## 链表

### 题目列表

- 2.两数相加
- 23.合并K个排序链表

### 题目类型

- 链表的合并

## 数学

## 双指针

### 题目列表

- 15.三数之和

## 字符串

### 分类

- 子序列

	- 不一定是连续的，原始字符串的一个子集

- 子串

	- 一定是连续的，原始字符串的一个连续子集

- 回文

	- 指正序（从左向右）和倒序（从右向左）读都是一样的整数或者字符。

### KMP 算法

- 算法流程

	- 假设现在文本串 S 匹配到 i 位置，模式串 P 匹配到 j 位置
	- 如果 j = -1，或者当前字符匹配成功（即 S[i] == P[j]），都令 i++，j++，继续匹配下一个字符；
	- 如果 j != -1，且当前字符匹配失败（即 S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串 P 相对于文本串 S 向右移动了 j - next [j]  位。
	- 换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的 next 值，即移动的实际位数为：j - next[j]，且此值大于等于 1。

- 步骤

	- 寻找前缀后缀最长公共元素长度

		- 寻找模式串中最大长度的相同前缀和后缀，找到了模式串中每个字符之前的前缀和后缀公共部分的最大长度后，便可基于此匹配。

	- 求 next 数组

		- 失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值

	- 根据next数组进行匹配

### 题目列表

- 6.Z 字形变换
- 44.通配符匹配
- 459.重复的子字符串  

## 二分查找

### 关键点

- 二分查找真正的坑在于到底要给 mid 加一还是减一，while 里到底用 <= 还是 <。
- 分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。
- int mid = left + (right - left) / 2;

### 分类 [1,2,2,2,3]

- 无边界二分查找
- 左侧边界二分查找
- 右侧边界二分查找

### 题目列表

- 4.寻找两个正序数组的中位数v
- 34.在排序数组中查找元素的第一个和最后一个位置
- 74.搜索二维矩阵
- 95.96.不同的二叉搜索树
- 240.搜索二维矩阵 II
- 300.字符串最长上升子序列
- 927.三等分

## 分治算法

### 分治就是不断缩小其规模，再不断合并扩大的过程

### 题目列表

- 23.合并K个排序链表

## 动态规划

### 动态规划问题的⼀般形式就是求最值

- 子序列

	- 最长上升子序列(LISLIS):Longest Increasing Subsequence
	- 最长连续序列(LCSLCS):Longest Consecutive Sequence
	- 最长连续递增序列(LCISLCIS):Longest Continuous Increasing Subsequence
	- 最长公共子序列(LCSLCS):Longest Common Subsequence

- 最⼩编辑距离
- 字符串动态规划

	- 解决两个字符串的动态规划问题，⼀般都是⽤两个指针 i,j 分别指向两个字符串的最后，然后⼀步步往前⾛，缩⼩问题的规模。
	- 只要涉及⼦序列问题，⼗有⼋九都需要
动态规划来解决

### 求解动态规划的核⼼问题是穷举、核心设计思想是数学归纳法


- 存在「重叠⼦问题」,暴⼒穷举的话效率会极其低下
- 优化穷举

	- 「备忘录」

		- 每次算出某个子问题的答案后不返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经存在泽直接把答案拿出来。
		- 一般使用数组、哈希表（字典）实现备忘录
		- 自顶向下

	- 「DP table」

		- 动态规划⼀般都脱离了递归，⽽是由循环迭代完成计算。（自底向上）
		- 把「备忘录」独⽴出来成为⼀张表，叫 DP table ，在这张表上完成「⾃底向上」的推算
		- 遍历

			- 正向遍历
			- 反向遍历
			- 斜向遍历

	- 动态规划问题⼀定会具备「最优⼦结构」，才能通过⼦问题的最值得到原问题的最值。
	- 只有列出正确的「状态转移⽅程」才能正确地穷举。

### 动态规划三要素

- 重叠子问题
- 最优子结构

	- 要符合「最优⼦结构」，⼦问题间必须互相独⽴。

- 状态转移方程（最难）

### 解题思维框架

- 明确「状态」、明确「选择」
-  定义 dp 数组/函数的含义
- 明确 base case
- 代码模板

	- 

### 题目列表

- 5.最长回文子串
- 44.通配符匹配
- 322.零钱兑换
- 416.分割等和子集
- 516.最长回文子序列
- 518.零钱兑换 II
- 877.石子游戏
- 1143.最长公共子序列

## 回溯算法

### 一种通过穷举所有可能情况来找到所有解的算法。

- 回溯算法关键在于:不合适就退回上一步

### 如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。

### 如果解决一个问题有多个步骤，每一个步骤有多种方法，题目又要我们找出所有的方法，可以使用回溯算法

### 回溯算法是在一棵树上的 深度优先遍历（因为要找所有的解，所以需要遍历）

### 题目列表

- 22.括号生成
- 44.通配符匹配
- 77.组合
- 78.子集

## 随机

## Rejection Sampling

## Sliding Window

## Ordered Map

## Line Sweep

## 记忆化

## 脑筋急转弯

## 递归

### 递归算法的时间复杂度

- ⼦问题个数乘以解决⼀个⼦问题需要的时间。

### 记忆递归

- 优化递归的标准方法。创建一个记忆的哈希映射。将所有已经检查的 (s, p) 保留在哈希映射中。这样，如果有任何重复的检查，只需查看哈希表，而不需再次进行计算。

## 二叉搜索树

## 线段树

## 树状数组

## 字典树

## 拓扑排序

## 设计

## 图

## 并查集

### 并查集，在一些有 N 个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。

### 一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。常常在使用中以森林来表示。

### 合并

- 把两个不相交的集合合并为一个集合

### 查询

- 查询两个元素是否在同一个集合中

## 广度优先搜索（BFS）

### 对树由上到下一层层遍历，需要一个数据结构来保存本层所有节点，方便进行下一层遍历

### 选择使用队列Queue，遍历本层节点的同时将下层节点加入队列尾部，且先进先出的特性，保证上层节点一定比下层节点先遍历。

## 深度优先搜索（DFS）

### 遍历由根节点到叶子节点的所有路径

### 关联回溯算法

### 树的 dfs 从上往下开始执行的时候因为递归分为递和归两部分（也就是往下传递和往回走）

## 树

### 做二叉树题目时候，第一想到的应该是用递归来解决。

### 二叉树的遍历

- 前序遍历、先序遍历

	- 根左右

- 中序遍历

	- 左根右

- 后序遍历

	- 左右根

- 深度优先搜索（DFS）
- 宽度优先搜索（BFS），层序遍历
- Morris（莫里斯）前中后遍历

### 题目列表

- 105.从前序与中序遍历序列构造二叉树

## 位运算

### 题目列表

- 78.子集

## 排序

### 分类

- 冒泡排序
- 选择排序
- 插入排序
- 快速排序
- 归并排序
- 堆排序
- 桶排序
- 基数排序
- 希尔排序
- 计数排序
- 位图排序
- 耐心排序

### 题目列表

- 56.合并区间
- 300.字符串最长上升子序列
- 977.有序数组的平方

## 贪心算法

### 一种在当前时间做出最佳可能决策的算法；

### 题目列表

- 12.整数转罗马数字
- 44.通配符匹配

## 堆

### 题目列表

- 23.合并K个排序链表

### 最大堆、最小堆，在 Java 中 PriorityQueue 就是其的实现

### 关于 Comparator ：如果 return 的大于 0 则前一位排在后一位的后面即升序，如果 return 的小于 0 则前一位排在后一位的的前面，为降序

## 栈

### 题目列表

- 20.有效的括号
- 剑指 offer 9.双栈实现队列

### 栈是一种 后进先出（last in - first out， LIFO）的数据结构，栈内元素从顶端压入（push），从顶端弹出（pop）。一般我们用数组或者链表来实现栈

### 单调栈

- 比普通的栈多一个性质，即维护一个栈内元素单调。
- 比如当前某个单调递减的栈的元素从栈底到栈顶分别是：[10, 9, 8, 3, 2]，如果要入栈元素5，需要把栈顶元素pop出去，直到满足单调递减为止，即先变成[10, 9, 8]，再入栈5，就是[10, 9, 8, 5]。

### 在表示问题的递归结构时，栈数据结构可以派上用场。

### 双栈可实现列表倒序

