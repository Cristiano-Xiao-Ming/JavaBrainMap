# 设计模式

## 六个创建型模式

### 简单工厂模式-Simple Factory Pattern

- 定义

	- 定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。
	- 因为在简单工厂模式中用于创建实例的方法是静态（static）方法，因此简单工厂模式又被称为静态工厂方法（Static Factory Method）模式

- 角色

	- Factory（工厂角色）

		- 工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；
		- 工厂类可以被外界直接调用，创建所需的产品对象；
		- 工厂类中提供了静态的工厂方法 factoryMethod()，它的返回类型为抽象产品类型Product。

	- Product（抽象产品角色）

		- 它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法
		- 提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。

	- Concreateproduct（具体产品角色）

		- 它是简单工厂模式的创建目标，所有被创建的对象都充
		- 当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在
		- 抽象产品中声明的抽象方法。

- 优缺点

	- 优点

		- 对象创建和使用的分离

			- 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅「消费」产品

		- 客户端不需要知道具体产品的类名

			- 只需要知道具体产品类所对应的参数即可

		- 根据「开放-封闭」原则，具体产品类的参数可以通过配置文件实现动态传参

	- 缺点

		- 工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。
		- 势必会增加系统中类的个数
		- 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑
		- 由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构

- 适用场景

	- 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
	- 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。

### 工厂方法模式-Factory Method Pattern

### 抽象工厂模式-Abstract Factory Pattern

### 单例模式-Singleton Pattern

保证一个类有且仅有一个实例,并提供一个访问它的全局访问点。

- 懒汉式单例

  顾名思义，就像你写代码的时候一定写过类似的「lazy=true」的代码，什么意思呢？就是这哥们比较懒，你让我干活，我才起床穿衣服给你干活，否则我猫着不出来活动。这种要在第一次被引用时，才会将自己实例化，所以就被称为懒汉式单例。

	- 第一次使用时创建实例
	- 无须一直占用系统资源
	- 必须考虑多线程问题

- 饿汉式单例

  顾名思义，就是它比较饥饿，在类初始化的时候你就杀愣的给人家的实例创建出来供别人使用。这种静态初始化的方式是在自己被加载时就将自己实例化，所以被形象地称之为饿汉式单例。

	- 类加载的时候即被创建
	- 无须考虑多线程，确保唯一性
	- 占用系统资源

- 并发条件下的懒汉式单例

	- volatile关键字修饰静态变量

	  被 volatile 修饰的成员变量可以确保多个线程都能够正确处理。

	- 双重锁定

	  如果 instance 为 null 并且这个有两个线程在调用 getInstance() 方法，他们都通过了第一重检查，然后因为锁的原因只能进去一个线程，另外一个被阻塞。如果这个时候没有第二重检查，那么第一个线程创建了实例，他出去的时候第二个线程进来还能创建新的实例，单例变成双例，那不扯淡呢吗？所以双重锁定必须加。

- 按需初始化单例（极致完美）

  按需初始化（Initialization on Demand Holder，简称 IoDH）的技术，该技术解决了饿汉式单例不能实现延迟加载，解决了懒汉式单例因为线程安全控制带来的性能和代码繁琐的诟病！

	- 声明静态内部类初始化静态变量

	  内部类中定义了一个 static 类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance() 方法没有任何线程锁定，因此其性能不会造成任何影响。

### 原型模式-Prototype Pattern

### 建造者模式-Builder Pattern

## 十一个行为型模式

### 职责链模式-Chain of Responsibility Pattern

### 命令模式-Command Pattern

### 解释器模式-Interpreter Pattern

### 迭代器模式-Iterator Pattern

### 中介者模式-Mediator Pattern

### 备忘录模式-Memento Pattern

### 观察者模式-Observer Pattern

### 状态模式-State Pattern

### 策略模式-Strategy Pattern

### 模板方法模式-Template Method Pattern

### 访问者模式-Visitor Pattern

## 七个结构型模式

### 适配器模式-Adapter Pattern

### 桥接模式-Bridge Pattern

### 组合模式-Composite Pattern

### 装饰模式-Decorator Pattern

- 动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活
- Component：定义一个对象接口，可以给这些对象动态地添加职责

	- ConcreteComponent：定义了一份具体的对象，可以给这个对象添加核心职责

		- Operation()

	- Decorator：装饰抽象类，扩展 Component 类的功能，但是 Component 无须知道 Decorator 的存在

		- ConcreteDecoratorA
		- ConcreteDecoratorB

- 装饰模式是为已有功能动态地添加更多功能的一种方式
- 把类中的装饰功能从类中搬移取去除，简化原有的类。有效的把类的核心职责和装饰功能区分。

### 外观模式-Facade Pattern

### 享元模式-Flyweight Pattern

### 代理模式-Proxy Pattern

- 为其他对象提供一种代理以控制对这个对象的访问。即给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。
- 代理模式的结构及角色

	- Subject（抽象主题角色）

		- 声明真实对象和代理对象的共同接口，保证在使用真实对象的地方都可以使用代理对象

	- Proxy（代理主题角色）

		- 代理对象需要包含对象真实对象的引用，从而可以在任何时候任何地点保证对真实对象的调用，甚至对真实对象的约束和修饰。

	- RealSubject（真实主题角色）

		- 实现真正的核心业务逻辑，客户端通过代理，代理再通过调用真实对象实现的核心操作完成业务逻辑

- 代理模式的类型

	- 远程代理：为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。
	- 虚拟代理：根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象
	- 安全代理：用来控制真实对象访问时的权限。
	- 智能指引，是指当调用真实的对象时，代理处理另外一些事实。
	- 缓冲代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端 可以共享这些结果。

## 七个面向对象设计原则

### 单一职责原则-Single Responsibility Principle

### 开闭原则-Open-Closed Principle

### 里氏代换原则-Liskov Substitution Principle

### 依赖倒转原则-Dependency Inversion Principle

### 接口隔离原则-Interface Segregation Principle

### 合成复用原则-Composite Reuse Principle

### 迪米特法则-Law of Demeter

