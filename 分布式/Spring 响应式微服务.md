# Spring 响应式微服务

本思维导图原文来自于《Spring 响应式微服务：Spring Boot 2 + Spring 5 + Spring  Cloud 实战》

## 一、直面响应式微服务架构

## 二、响应式编程模型与 Reactor 框架

### 响应式编程模型

- 流

	- 概念

		- 由生产者生产并由一个或多个消费者消费的元素的序列（发布/订阅模型）

			- 推模型

				- 生产者将元素推送给消费者

			- 拉模型

				- 消费者从生产者中拉取元素

			- 生产者与消费者之间的同步异步区别

	- 流量控制

		- 节流

			- 消费者直接丢弃无法处理的元素

		- 使用缓冲区

			- 当生产者比消费者快的时候，消费者可以采用无边界缓冲区来保存生产者产生的元素
			- Java 中的无边界缓冲队列

				- LinkedBlockingQueue（几乎无边界，Integer 最大值）
				- PriorityBlockingQueue（受系统资源的影响）
				- DelayQueue、LinkedTransferQueue
				- ConcurrentLinkedQueue（非阻塞队列）

		- 调用栈阻塞

			- 同步线程

		- 使用背压

			- 消费者需要多少，生产者就生产多少

- 背压

	- 背压机制

		- 消费者在消费由生产者生产的数据的同时，也需要有一种能够向上游反馈流量需求的机制，这种机制就是背压机制

	- 背压的实现方式

		- 阻塞式背压

			- 生产者和消费者处于同一线程，当消费者消费的时候阻塞生产者的生产

		- 非阻塞式背压（推荐）

			- 采用拉模型，即消费者会要求生产者生成多少消息量，最多只能生产多少，然后等待消费者的命令。

- 响应式流（预先定义好的接口）

	- 响应式流规范

		- 目标是定义将数据流从生产者传递到消费者而不需要生产者阻塞
		- 消费者向生产者发送多个元素的异步请求，生产者向消费者发送合适数量的元素

	- 响应式流接口

		- Publisher<T>

			- 潜在的包含无限数量的有序元素的生产者，他根据收到的请求向当前订阅者发送元素

		- Subscriber<T>

			- 订阅者从发布者哪里订阅并接收元素。

		- Subscription

			- 表示订阅者订阅的一个发布者的令牌

		- Processor<T,R>

			- 处理器充当订阅者和发布者之间的处理媒介，类似于将发布者提供的 T 类型数据转换为 R 类型数据发给订阅者

### Reactor 框架

- 响应式编程实现技术概述

	- 实现异步操作的常见方式

		- 回调

			- 类 A 调用类 B 的方法 b，b 方法执行完毕后主动调用类 A 的方法 a
			- 对于大规模的嵌套多层异步组合来说显得非常笨拙，很快导致代码那一理解和维护

		- Future

			- 虽然可以实时获取异步执行的结果，但是没有通知机制，无法得知任务什么时候完成，为了获取结果，要么使用阻塞的 get() 方法，要么就是使用 isDone() 轮询判断任务是否完成
			- CompletableFuture

	- 响应式编程的主流实现技术

		- Rxjava

			- 类库

		- Akka Streams

			- 运行在 JVM 上

		- Vert.x

			- Eclipse 旗下开源的 Java 工具

		- Project Reactor

			- Spring 5 引入的响应式编程机制
			- 核心组件

				- Flux

					- 代表包含 0 到 n 个元素的异步序列

				- Mono

					- 表示包含 0 个或 1 个元素的异步序列

- 引入 Reactor 框架

	- Reactor 异步数据序列

		- onNext()

			- 正常的包含元素的消息通知

		- onComplete()

			- 序列结束的消息通知，可以没有
			- 不调用就是无限异步序列

		- onError()

			- 序列出错的消息通知，可以没有

	- Flux 组件

		- 包含 0 到 n 个元素的异步序列，上述三种消息通知都适用于 Flux

	- Mono 组件

		- 表示包含 0 个或 1 个元素的异步序列，也可以包含上述三种类型的消息通知
		- 也可用来表示一个空的异步序列，该序列没有任何元素，仅仅包含序列结束的高年，使用 Mono<Void> 表示

### 创建 Flux 和 Mono

- 创建 Flux

	- 通过静态方法创建 Flux

		- just()

			- 可以指定序列中包含的全部元素，创建出来的 Flux 序列在发布这些元素之后会自动结束

		- fromArray()、fromIterable()、fromStream()

			- 基于已经存在一个数组、Iterable 对象或者 Stream 对象，可以使用这些方法从对象中自动创建 Flux 对象

		- empty()、error()、never()

			- empty() 可以创建一个不包含任何元素而只发布结束消息的序列
			- error() 方法创建一个只包含错误消息的序列
			- never() 方法创建一个不包含任何消息通知的序列

		- range()

			- 可以创建包含从 start 起始的 count 个对象的序列，序列中所有的对象类型都是 Integer

		- interval()

			- 表现为一个方法序列，序列中的元素按照指定的时间间隔来发布

	- 动态创建 Flux

		- generate()

			- 通过同步和注意的方式来产生 Flux 序列，依赖于 Reactor 提供的 SynchronousSink 组件

				- next()，最多只能被调用一次
				- complete()
				- error()

		- create()

			- 使用 FluxSink 组件，支持同步和异步的消息生产方式，在一次调用中可以产生多个元素

- 创建 Mono

	- Flux 的上述创建方法 Mono 同样适用
	- delay()

		- 在指定的延迟时间之后会产生数字 0 作为唯一值

	- justOrEmpty()

		- 从一个 Optional 对象创建 Mono，只有当 Optional 对象中包含值是，Mono 序列才产生对应的元素

	- Mono 的动态创建也是使用 create() 并使用 MonoSink 组件

### Flux 和 Mono 操作符

- 操作符类型

	- 转换

		- 负责对序列中的元素进行转变

	- 过滤

		- 将不需要的数据从序列中进行过滤

	- 组合

		- 负责将序列中的元素进行合并和连接

	- 条件

		- 负责根据特定条件对序列中的元素进行处理

	- 数学

		- 负责对序列中的元素执行各种数学操作

	- Observable 工具

		- 提供一些针对流失处理的辅助性工具类

	- 日志和调试

		- 针对运行时日志以及如何对序列进行代码挑食的工具类

- 转换操作符

	- buffer

		- 把当前流中的元素收集到集合中，并把集合对象作为流中的新元素
		- 指定收集的时间间隔
		- bufferUntil
		- bufferWhile

	- map

		- 映射操作，对流中的每个元素应用一个映射函数，从而达到变换效果

	- flatMap

		- 把六中的每个元素转换成一个流，再把转换之后得到的所有流中的元素进行合并

	- window

		- 类似于 buffer，但是是把当前流中的元素收集到另外一个 Flux 中

- 过滤操作符

	- filter

		- 过滤器

	- first

		- 返回流中第一个元素

	- last

		- 返回流中最后一个元素

	- skip/skipLast

		- 忽略数据流的前（后） n 个元素

	- take/takeLst

		- 从当前流中的前（后）面取 n 个元素

- 组合操作符

	- then/when

		- then：等到上一个操作完成再做下一个
		- when：等到多个操作一起完成

	- merge

		- 把多个流合并成一个 Flux 序列

	- startWith

		- 在数据元素序列的开头插入指定的元素项

	- zipWith

		- 把当前流中的元素与另外一个六中的元素按照一对一的方式进行合并

- 条件操作符

	- defaultEmpty

		- 如果原始数据流中没有元素，返回一个默认的元素

	- takeUntil

		- 提取元素直到断言条件返回 true

	- takeWhile

		- 在断言条件返回 true 时才进行元素的提取

	- skipUntil

		- 丢弃原始数据流中的元素直到断言为 true

	- skipWhile

		- 断言为 true 时才进行元素的丢弃

- 数学操作符

	- concat

		- 合并来自于不同的 Flux 的数据

	- count

		- 统计 Flux 中所有元素的个数

	- reduce

		- 对所有的元素进行累计操作，得到一个包含计算结果的 Mono 序列

- Observable 工具操作符

	- delay

		- 将事件的传递向后延迟一段时间

	- subscribe

		- 添加相应的订阅逻辑

	- timeout

		- 特定时间段内没有产生任何时间时，将生成一个异常

	- block

		- 在接收到下一个元素之前一直阻塞

- 日志和调试操作符

	- log

		- 用于观察所有的数据并使用日志工具进行跟踪

	- debug

		- 所有的操作符在执行时都会保存与执行立案相关的额外信息

### Reactor 框架中的背压机制

- 处理策略

	- ERROR

		- 当下游跟不上节奏时发出一个错误信号

	- DROP

		- 当下游没有准备好接收新的元素时抛弃这个元素

	- LATEST

		- 让下游只得到上游最新的元素

	- BUFFER

		- 缓存下有没有来得及处理的元素

	- IGNORE

		- 完全忽略下游背压请求

## 分支主题 3

*高老四博客 - glorze.com*