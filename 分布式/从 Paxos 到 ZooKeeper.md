# 从 Paxos 到 ZooKeeper

## 一、分布式架构

### 从集中式到分布式

- 集中式的特点

	- 一台或者多台主机组成中心节点，数据集中存储，所有业务单元集中部署在这个中心节点上，负责所有的功能处理。
	- 客户端仅仅负责数据的录入和输出，数据的存储与控制完全交由主机完成
	- 最大的特点就是部署结构简单，无须考虑多个节点之间的分布式写作问题

- 分布式的特点

	- 分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。
	- 分布式的特征

		- 分布性

			- 多台计算机在空间上随意分布

		- 对等性

			- 计算机没有主从之分
			- 副本指的是分布式系统对数据和服务提供的一种冗余方式

		- 并发性

			- 并发性操作是非常常见的行为，比如一些一些共享的资源、数据库或分布式存储等

		- 缺乏全局时钟

			- 在分布式系统中，很难定义两个时间酒精谁先谁后，原因就是缺乏一个全局的时钟序列控制

		- 故障总是会发生

			- 有可能发生任何形式的故障，任何设计阶段考虑到的异常情况，一定会在系统实际运行中发生

- 分布式环境的各种问题

	- 通信异常

		- 光纤
		- 路由器
		- DNS
		- 网络延时

	- 网络分区（脑裂）

		- 出现局部小集群，不能组合成完整的分布式功能，可能会对数据库事务造成影响

	- 三态

		- 成功
		- 失败
		- 超时

			- 发送过程中消息丢失
			- 响应反馈消息丢失

	- 节点故障

		- 节点宕机或者僵死

### 从 ACID 到 CAP/BASE

- ACID

	- 事务

		- 由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元（Unit），狭义上的事务特指数据库事务。

	- 原子性（Atomicity）

		- 原子操作

			- 全部成功执行
			- 全部不执行

	- 一致性（Consistency）

		- 事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。
		- 诗句哭只包含成功事务提交的结果时，就能说数据库处于一致性状态

	- 隔离性（Isolation）

		- 并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰
		- 未提交读

			- 允许脏读，隔离级别最低

		- 已提交读
		- 可重复读
		- 串行化

	- 持久性（Durability）

		- 指一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的。

- 分布式事务

	- 分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点之上。
	- 通常一个分布式事务中会涉及对多个数据源或业务系统的操作。

- CAP/BASE 理论

	- CAP 定理

		- 一个分布式系统不可能同时满足一致性、可用性和分区容错性这三个基本需求，最多只能同时满足其中的两项
		- 一致性

			- 数据在多个副本之间是否能够保持一致的特性，执行更新操作后，应该保证系统的数据仍然处于一致的状态

		- 可用性

			- 服务必须一致处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果

		- 分区容错性

			- 分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障

	- BASE 理论

		- 基本可用

			- 响应时间 上的损失
			- 功能上的损失

		- 弱状态

			- 允许系统在不用几点的数据副本之间进行数据同步的过程存在延时

		- 最终一致性

			- 需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性
			- 因果一致性

				- A 更新后通知了 B，B 之后对数据的访问应该能够获取到 A 更新后的最新值，B 的更新也要基于 A 更新后的最新值，不能不能发生丢失更新的情况

			- 读已之所写

				- A 更新一个数据项之后自己总是能够访问到更新过的最新值

			- 会话一致性

				- 执行更新操作之后，客户端能够在同一个会话中时钟读取到该数据项的最新值。

			- 单调读一致性

				- 如果一个进程从系统中读取出一个数据项的某个值，系统对于该进程后续的任何数据访问都不应该返回旧值

			- 单调写一致性

				- 同一个进程的写操作被顺序地执行

## 二、一致性戏协议

### 2PC 与 3PC

- 2PC（二阶段提交）

	- 保持原子性和一致性的一中短发
	- 阶段一：提交事务请求（投票阶段）

		- 事务询问

			- 协调者向所有的参与者发送食物内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应

		- 执行事务

			- 各参与者节点执行事务操作，并将 Undo 和 Redo 信息记入事务日志中

		- 各参与者向协调者反馈事务询问的响应

			- 如果参与者成功执行事务操作，反馈 Yes，表示事务可以执行
			- 反之反馈 No，表示事务不可以执行

	- 阶段二：执行事务提交

		- 执行事务提交

			- 发送提交请求

				- 协调者向所有参与者节点发出 Commit 请求

			- 事务提交

				- 参与者接收到 Commit 请求后正式执行事务的提交操作，完成比较滞后释放占用的事务资源

			- 反馈事务提交结果

				- 参与者在完成事务提交之后向协调者发动 Ack 消息

			- 完成事务

				- 协调者接收到所有参与者反馈的 Ack 消息后完成事务

		- 中断事务

			- 发送回滚请求

				- 协调者向所有参与者节点发出回滚 Rollback 请求

			- 事务回滚

				- 参与者收到回滚请求后利用 Undo 信息执行事务回滚，完成回滚之后释放占用的资源

			- 反馈事务回滚结果

				- 参与者完成事务回滚之后向协调者发送 Ack 消息

			- 中断事务

				- 协调者接收到所有参与者反馈的 Ack 消息之后，完成事务中断

	- 优点

		- 原理简单，实现方便

	- 缺点

		- 同步阻塞

			- 所有参与事务的逻辑都处于阻塞状态，无法进行其他任何操作

		- 单点问题

			- 协调者如果出问题，流程无法运转，甚至在第二阶段会让参与者一直处于索性事务资源的状态中

		- 脑裂

			- 阶段二如果发生了局部网络异常或者协调者在尚未发送完 Commit 请求之前自身崩溃会导致收到 Commit 的参与者执行事务，没收到的不执行，数据不一致

		- 太过保守

			- 如果参与者崩溃会导致协调者不能回去所有参与饿着的响应信息，协调者只能依靠自身的超时机制判断是否需要中断事务
			- 二阶段提交斜体没有较为完善的容错机制，任意一个节点的失败都会导致整个事务的失败

- 3PC（三阶段提交）

	- 将 2PC 的第二阶段的「提交事务请求」一分为二，形成 CanCommit、PreCommit 和 do Commit 三个阶段组成的事务处理协议
	- 阶段一：CanCommit

		- 事务询问
		- 各参与者向协调者反馈事务询问的响应

	- 阶段二：PreCommit

		- 执行事务预提交

			- 发送与提交请求
			- 事务预提交
			- 各参与者向协调者反馈事务执行的响应

		- 中断事务

			- 发送中断请求
			- 中断事务

	- 阶段三：doCommit

		- 执行提交

			- 发送提交请求
			- 事务提交
			- 反馈事务提交结果
			- 完成事务

		- 中断事务

			- 发送中断请求
			- 事务回滚
			- 反馈事务回滚结果
			- 中断事务

		- 可能故障

			- 协调者出现问题
			- 协调者和参与者之间的网络之间出现故障

	- 优点

		- 降低参与者的阻塞范围，单点故障后继续达成一致

	- 缺点

		- 参与者接收到 PreCommit 消息之后，如果出现网络分区，协调者与参与者无法正常网络通信，参与者会进行实物的提交，出现数据的不一致性

### Paxos 算法

- 追本溯源
- Paxos 理论的诞生
- Paxos 算法详解

	- 「过半」理念

## 三、Paxos 的工程实践

### Chubby

- 概述
- 应用场景
- 设计目标
- Chubby 技术架构
- Paxos 协议实现

### Hypertable

- 概述
- 算法实现

## 四、ZooKeeper 与 Paxos

### 初识 Zookeeper

- ZooKeeper 介绍

	- Chubby 的开源实现，典型的分布式数据一致性的解决方案

		- 发布/订阅
		- 负载均衡
		- 命名服务
		- 分布式协调/通知
		- 集群管理
		- Master 选举
		- 分布式锁
		- 分布式队列

	- ZooKeeper 可以保证分布式一致性的类型

		- 顺序一致性

			- 按照发起顺序执行

		- 原子性

			- 整个集群所有机器成功应用事务

		- 单一视图

			- 无论客户端连接任意一个 ZK 服务器看到的服务端诗句模型都是一致的

		- 实时性

			- ZK 仅仅保证一定的时间段内客户端最终的最新数据状态

		- 可靠性

			- 服务端在完成事务之后的状态变更会被一直保留

	- 设计目标

		- 简单的数据模型

			- 一系列 ZNode 数据节点组成，类似于一个文件系统，存储在内存中以此实现提高服务器吞吐、减少延迟的目的

		- 可以构建集群

			- 在内存中维护当前的服务器状态，机器之间互相通信
			- 只要集群中存在超过一半的机器正常工作，整个集群就能够正常对外服务

		- 顺序访问

			- 来自客户端的每个更新请求，ZK 都会分配一个全局唯一的递增编号，这个编号反应快乐所有事物操作的先后顺序，从而实现更高层次的同步原语

		- 高性能

			- 全量数据存储在内存中，直接服务与客户端的所有非事物请求，尤其适用与读操作为主的应用场景

- ZooKeeper 从何而来
- ZooKeeper 的基本概念

	- 集群角色

		- 最典型的集群模式就是主备模式（Master/Slave）

			- Master 处理所有写操作
			- Slave 负责异步复制获取最新数据，并且提供读服务

		- ZK 中引入了 Leader、Follower、Observer

			- 通过选举选定一台「Leader」，为客户端提供读和写服务
			- Follower 和 Observer 都提供读服务，Observer 不参与 Leader 选举过程，也不参与「过半写成功」策略，单纯的提高读性能

	- 会话（Session）
	- 数据节点

		- 机器节点

			- 构成 ZK 集群的机器称之为机器节点

		- 数据模型中的数据单元称之为数据节点（ZNode）

			- 持久节点

				- 除非手动删除

			- 临时节点

				- 生命周期和客户端会话绑定，客户端失效，临时节点被移除

	- 版本

		- 每个 ZNode 都会维护一个叫做 Stat 的数据结构，Stat 记录 Znode 的三个数据版本

			- version

				- ZNode 的当前版本

			- cversion

				- ZNode 子节点的当前版本

			- aversion

				- ZNode 的 ACL 版本

	- Watcher（事件监听器）

		- 允许用户在指定节点上注册一些 Watcher，在一些特定事件触发的时候，ZK 会通知到感兴趣的客户端上去

	- ACL（权限控制）

		- CREATE

			- 创建子节点的权限

		- READ

			- 获取节点数据和子节点列表的权限

		- WRITE

			- 更新节点数据的权限

		- DELETE

			- 删除子节点的权限

		- ADMIN

			- 设置节点 ACL 的权限

- 为什么选择 ZooKeeper

	- 成熟稳定且被大规模应用
	- 开源
	- 免费

### ZooKeeper 的 ZAB 协议

- ZAB 协议

  所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为  Leader 服务器，而余下的其他服务器则成为 Follower 服务器。Leader 服务器负责将一个客户端事务请求转换成一个事务 Proposal（提议），并将该 Proposal 分发给集群中所有的 Follower 服务器。之后 Leader 服务器需要等待所有 Follower 服务器的反馈，一旦超过半数的 Follower 服务器进行了正确的反馈后，那么 Leader 就会再次向所有的 Follower 服务器分发 Commit 消息，要求其将前一个 Proposal 进行提交。

	- ZK 并没有完全采用 Paxos 短发，而是采用 ZAB 协议作为其数据一致性的核心算法
	- 实现了一种主备模式的系统架构来保持集群中各副本之间数据的一致性。

- 协议介绍

	- 崩溃恢复

		- 选举产生新的 Leader 服务器
		- 只允许唯一的一个 Leader 服务器来进行失去请求的处理
		- 让最高编号事务 Proposal 的机器来称为 Leader

	- 消息广播

		- 原子广播协议，类似于一个二甲段提交过程
		- 对客户端的事务请求，Leader 服务器会为其生成对应的事务 Proposal，并将其发送给集群中其余所有的机器，然后再分别收集各自的选票，最后进行事务提交。

- 深入 ZAB 协议

	- 系统模型

		- 完整性
		- 前置性

	- 问题描述

		- 主进程周期
		- 事务

	- 算法描述

		- 发现

			- Leader 选举

		- 同步
		- 广播

			- 接收客户端的时区请求并进行消息广播流程

	- 运行分析

		- 每一个进程的可能状态

			- LOOKING

				- Leader 选举阶段

			- FOLLOWING

				- Follower 服务器和 Leader 保持同步状态

			- LEADING

				- Leader 服务器作为主进程领导状态

- ZAB 与 Paxos 算法的联系与区别

	- 两者都存在一个类似于 Leader 进程的角色，由其负责协调多个 Follower 进程的运行
	- Leader 进程都会等待超过半数的 Follower 做出正确的反馈后，才会将一个提案进行提交。
	- 在 ZAB 协议中，每个 Proposal 中都包含了一个 epoch 值，用来代表当前的 Leader 周期，在 Paxos 算法中，同样存在这样的一个标识，只是名字变成了 Ballot
	- 协议主要用于构建一个高可用的分布式数据主备系统
	- Paxs 算法则是用于构建一个分布式的一致性状态机系统。

## 八、ZooKeeper 运维

## 七、ZooKeeper 技术内幕

### 系统模型

- 数据模型

	- 树

		- ZNode 是 ZooKeeper 中数据的最小单元，每个 ZNode 上都可以保存数据，同时还可以挂载子节点，因此构成了一个层次化的命名空间，我们称之为树。

	- 事务 ID

		- 在 Zookeeper 中，事务是指能够改变 Z0 keeper 服务器状态的操作，我们也称之为事务操作或更新操作，一般包括数据节点创建与删除、数据节点内容更新和客户端会话创建与失效等操作。
		- 对于每一个事务请求，ZooKeeper 都会为其分配一个全局唯一的事务 ID，用 ZXID 来表示，通常是一个 64 位的数字。
		- 每一个 ZXID 対应一次更新操作，从这些 ZXID 中可以间接地识别出 ZooKeeper 处理这些更新操作请求的全局顺序。

- 节点特性

	- 节点类型

		- 每个数据节点都是有生命周期的，长短取决于数据节点的类型

			- 持久节点

				- 手动删除

			- 临时节点

				- 和客户端的会话绑定在一起

			- 顺序节点

				- 持久顺序节点
				- 临时顺序节点

			- 状态信息

				- 每个数据节点除了存储了数据内容之外，还存储了数据节点本身的一些状态信息

					- 事务 ID
					- 版本信息
					- 子节点个数

- 版本

	- version
	- cversion
	- aversion

- Watcher：数据变更的通知

	- Watcher 接口
	- Watch 事件

- ACL：保障数据的安全

### 序列化与协议

- Jute 介绍
- 使用 Jute 进行序列化
- 深入 Jute
- 通信协议

### 客户端

- ZooKeeper 实例

	- 客户端的入口

- ClientWatchManager

	- 客户端 Watch 管理器

- HostProvider

	- 客户端地址列表管理器

- ClientCnxn

	- 客户端核心线程

		- SendThread

			- 客户端和服务端之间的所有网络 I/O

		- EventThread

			- 客户端的事件处理

- 一次会话的创建过程

	- 初始化 ZooKeeper 对象
	- 设置会话默认 Watcher
	- 构造 ZooKeeper 服务器地址列表管理器：HostProvider。
	- 创建并初始化客户端网络连接器：ClientCnxn。
	- 初始化 SendThread 和 EventThread。
	- 启动 SendThread 和 EventThread
	- 获取一个服务器地址
	- 创建 TCP 连接
	- 构造 ConnectRequest 请求
	- 发送请求
	- 接收服务端响应
	- 处理 Response
	- 连接成功
	- 生成时间：SyncConnected-Node
	- 查询 Watcher
	- 处理事件

- 服务器地址列表
- ClientCnxn：网络 I/O

### 会话

- 会话状态

	- CONNECTING
	- CONNECTED
	- RECONNECTING
	- RECONNECTED
	- CLOSE

- 会话创建
- 会话管理

	- 分桶策略

- 会话清理
- 重连

### 服务器启动

- 单机版服务器启动
- 集群版服务器启动

### Leader 选举

- Leader 选举概述

	- 服务器启动时期的 Leader 选举

		- 每个 Server 会发出一个投票
		- 接收来自各个服务器的投票
		- 处理投票
		- 统计投票
		- 改变服务器状态

	- 服务器运行期间的 Leader 选举

		- 变更状态

			- 将自己的状态改为 LOOKING，然后开始进入 Leader 选举过程

		- 每个 Server 会发出一个投票
		- 接收来自各个服务器的投票
		- 处理投票
		- 统计投票
		- 改变服务器状态

- Leader 选举的算法分析
- Leader 选举的实现细节

### 各服务器角色介绍

- Leader

	- 事务请求的唯一调度和处理者，保证集群事务处理的顺序性。
	- 集群内部各服务器的调度者。
	- 请求处理链

- Follower

	- 处理客户端非事务请求，转发事务请求给 Leader 服务器。
	- 参与事务请求 Proposal 的投票。
	- 参与 Leader 选举投票

- Observer

	- 对于事务请求，则会转发给 Leader 服务器进行处理。

- 集群间消息通信

### 请求处理

- 会话创建请求
- SetData 请求
- 事务请求转发
- GetData 请求

### 数据与存储

- 内存数据
- 事务日志
- snapshot-数据快照
- 初始化

## 六、ZooKeeper 的典型应用场景

### 典型应用场景及实现

- 数据发布/订阅
- 负载均衡

	- 动态 DNS

- 命名服务
- 分布式协调、通知
- 集群管理
- Master 选举
- 分布式锁

	- 获取锁

		- 在需要获取排他锁时，所有的客户端都会试图通过调用 create 接口，在 / exclusive_lock 节点下创建临时子节点 /exclusive_ lock/lock。
		- Zookeeper 会保证在所有的客户端中，最终只有一个客户端能够创建成功，那么就可以认为该客户端获取了锁。
		- 没有获取到锁的客户端注册一个子节点变更的 Watcher 监听，实时监听到 lock 节点的变更情况

	- 释放锁

		- 当前获取锁的客户端机器发生宕机，那么 Zookeeper 上的这个临时节点就会被移除。
		- 正常执行完业务逻辑后，客户端就会主动将自己创建的临时节点删除。

- 分布式队列

### ZooKeeper 在大型分布是系统中的应用

- Hadoop
- HBase
- Kafka

### ZooKeeper 在阿里巴巴的实践与应用

- RPC 服务框架：Dubbo

	- Dubbo 核心部分

		- 远程通信

			- 提供对多种基于长连接的 NIO 框架抽象封装，包括多种线程模型、序列化，以及「请求一响应」模式的信息交换方式。

		- 集群容错

			- 提供基于接口方法的远程过程透明调用，包括对多协议的支持，以及对软负载均衡、失败容错、地址路由和动态配置等集群特性的支持。

		- 自动发现

			- 提供基于注册中心的目录服务，使服务消费方能动态地査找服务提供方，使地址透明，使服务提供方可以平滑地增加或减少机器。

## 五、使用 ZooKeeper

### 部署与运行

- 系统环境
- 集群与单机
- 运行服务

### 客户端脚本

### Java 客户端 API 使用

### 开源客户端

- ZKClient
- Curator

