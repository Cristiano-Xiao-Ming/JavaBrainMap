# Redis

## 基础数据结构（key 都是字符串，value 对应着不同的数据结构）

### string（字符串）

- 缓存用户信息（JSON 序列化）、计数
- 预分配冗余空间的形式设计，每次扩容 1M，最多 512M，类似于 Java 中的 ArrayList 的设计

### list（列表）

- 常用于做异步队列
- 相当于 Java 中的链表（LinkedList），插入删除块，索引慢，弹出最后一个元素的时候数据结构自动被删除。
- ziplist（快速列表）

	- 列表元素较少的情况是使用一块连续的内存存储加速元素的访问
	- 元素量大的时候 ziplist 会与链表结合组成 quicklist，将 ziplist 使用双向指针串联起来使用

### hash（字典）

- 类似 Java 中的 hashMap，采用数组加链表的形式
- 当 hash 移除了最后一个元素之后，该数据结构自动被删除，内存被回收。
- 一般也用于存储用户信息，可以针对字段做自定义单独存储
- 存储消耗相对于要高于字符串

### set（集合）

- 相当于 Java 里面的 HashSet，键值对无序但唯一
- 当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。
- 常用于存储活动中奖的用户 ID

### zset（有序列表）

- 类似于 Java 中的 SortedSet 和 HashMap 的结合体
- zset 中最后一个 value 被移除后，数据结构自动删除，内存被回收。
- 常用于存储粉丝列表，比如 value 代表粉丝 ID，score 代表关注时间，从而可以按照时间排序
- 也可用于存储学生成绩，value 代表学生 ID，score 代表考试成绩，从而按照成绩排名
- 跳跃列表

	- zset 的内部排序功能通过「跳跃列表实现」
	- 类似于层级制，或者你可以想象为这张思维导图的样子

## 集群方案

### 官方 redis-cluster 路由查询

- 优势：所有功能都集成在 redis cluster 中，路由分片、拓扑信息的存储、探活都在 redis cluster 中实现；各实例间通过 gossip 通信；这样的好处是简单，依赖的组件少
- 劣势：需要支持更大的规模时，由于使用 gossip 协议导致协议之间的通信消耗太大，redis cluster 不再合适；
- 
- 服务器端分片技术

### twemproxy 代理、nutcracker

- 原理：twemproxy 处于客户端和服务器的中间，将客户端发来的请求，进行一定的处理后（sharding），再转发给后端真正的redis服务器。
- 客户端不直接访问redis服务器，而是通过twemproxy代理中间件间接访问。降低了客户端直连后端服务器的连接数量，并且支持服务器集群水平扩展。
- 中间件做分片的技术
- 

	- 

		- 

### codis

- 特点

	- 分片算法：基于 slot hash 桶；
	- 分片实例之间相互独立，每组 一个 master 实例和多个 slave；
	- 路由信息存放到第三方存储组件，如 zookeeper 或 etcd
	- 旁路组件探活

- 划分了 1024个slot， slots 信息在 proxy层感知； redis 进程中维护本实例上的所有key的一个slot map；
- 图片可拖拽放大

### 哨兵模式（Sentinel）

- 原理：由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器以及这些主服务器下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。
- 

	- 

		- 

### 客户端分片，一致性哈希

- 关于一致性 Hash 算法，可以参考一下老四的这片文章《Java 十道由浅入深的笔面试题第四期》。http://www.glorze.com/1476.html

## 缓存

### 缓存击穿

- 概念：请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。
- 问题：黑客拿数据库中不存在的字段值进行大量的请求导致服务宕机
- 解决方式

	- 缓存控制，定期设置过期时间
	- 哈希过滤

### 缓存穿透

- 概念：大量的请求同时查询一个 key 时，此时这个 key 正好失效了，就会导致大量的请求都打到数据库上面去
- 问题：造成数据库瞬间请求过载，压力陡增，服务宕机
- 解决方式

	- 请求线程加锁，或者数据库查询加锁
	- 数据返回记录之后作为缓存承载给其他请求

### 缓存雪崩

- 概念：缓存服务宕机，导致大量请求直接打进数据库造成服务宕机
- 问题：数据库由于请求量过大而崩溃 
- 解决方式

	- 缓存集群
	- 如果是微服务，可以设置网关限流
	- 使用缓存技术中的本地缓存（缓存在硬盘中）
	- 设置 Redis 持久化，服务重启之后自动加载数据缓存到 Redis 中

### 热点数据集中失效

- 概念：缓存都有失效时间，那么作为热点数据失效的瞬间也会有大量的请求直接涌入到数据库
- 解决方式

	- 不同的热点数据设置不同的失效时间
	- 互斥锁

### 更新数据的时候先删除缓存还是先进行数据更新？

- 先删缓存再更新数据

	- 产生脏数据的概率较大，查询得到旧数据，多数不建议这样做

- 先更新数据再删除缓存

	- 脏数据产生概率低，但是会出现一致性异步问题，但是问题不大，数据更新之后更新缓存即可。多数情况建议选择此种方式

## Redis 锁

### 客户端可以使用同步机制

### 服务器端

- setnx

### 分布式锁

- 利用 setnx+expire 命令

	- SETNX 是 SET IF NOT Exists 的缩写，即 setnx key value，将 key 设置为 value，当键不存在时，才能成功，若键存在，什么也不做，成功返回 1，失败返回 0 。
	- 因为 setnx + expire 命令过程中不具有原子性，所以不推荐直接使用
	- 可以优化为使用 Lua 脚本将两个命令封装为一个操作进行使用，不过依然不推荐

-  使用 set key value [EX seconds][PX milliseconds][NX|XX] 命令 (推荐)

	- EX seconds: 设定过期时间，单位为秒
	- PX milliseconds: 设定过期时间，单位为毫秒
	- NX: 仅当key不存在时设置值
	- XX: 仅当key存在时设置值

- Redlock算法 与 Redisson 实现

	- 主要解决上一条锁在集群、多节点的情况下锁失效的问题
	- 获取当前时间
	- 发起请求，并设置超时时间，超时时间要小于锁的过期时间
	- 使用当前时间减掉开始获取锁的时间得到获取锁所使用的时间，这个时间要满足小于锁失败的时间并且实例当中超过一半的实例都获取到了锁才算成功
	- 如果锁获取失败，Redis 所有实例进行解锁，及时某些实例没有枷锁成功

## Redis 并发

### 大量数据插入使用管道（pipe）

## 数据淘汰策略（lru、随机、将要过期、不淘汰）

### volatile-lru

- 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰

### volatile-ttl

- 从已设置过期时间的数据集中挑选将要过期的数据淘汰

### volatile-random

- 从已设置过期时间的数据集中任意选择数据淘汰

### allkeys-lru

- 从数据集中挑选最近最少使用的数据淘汰

### allkeys-random

- 从数据集中任意选择数据淘汰

### no-enviction

- 禁止驱逐数据

## Redis 为什么快

### 基于内存

### 单线程节省上下文开销

###  I/O 多路复用

- 多路 - 指的是多个 socket 连接，也就是多个网络连接
复用 - 指的是复用一个线程。

	- 让单个线程高效的处理多个连接请求，从而减少网络请求浪费的时间
	- select
	- poll
	- epoll

		- 子主题 1

### 数据结构使用 hash 设计

