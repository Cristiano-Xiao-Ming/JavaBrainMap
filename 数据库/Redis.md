# Redis

## 基础数据结构（key 都是字符串，value 对应着不同的数据结构）

### string（字符串）

- 缓存用户信息（JSON 序列化）、计数
- 预分配冗余空间的形式设计，每次扩容 1M，最多 512M，类似于 Java 中的 ArrayList 的设计

### list（列表）

- 常用于做异步队列
- 相当于 Java 中的链表（LinkedList），插入删除块，索引慢，弹出最后一个元素的时候数据结构自动被删除。
- ziplist（快速列表）

	- 列表元素较少的情况是使用一块连续的内存存储加速元素的访问
	- 元素量大的时候 ziplist 会与链表结合组成 quicklist，将 ziplist 使用双向指针串联起来使用

- 最多存储 2^32 - 1 个元素，可以充当数组、队列、栈使用

### hash（字典）

- 类似 Java 中的 hashMap，采用数组加链表的形式
- 当 hash 移除了最后一个元素之后，该数据结构自动被删除，内存被回收。
- 一般也用于存储用户信息，可以针对字段做自定义单独存储
- 存储消耗相对于要高于字符串

### set（集合）

- 相当于 Java 里面的 HashSet，键值对无序但唯一
- 当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。
- 常用于存储活动中奖的用户 ID
- 最多存储 2^32 - 1 个元素

### zset（有序列表）

- 类似于 Java 中的 SortedSet 和 HashMap 的结合体
- zset 中最后一个 value 被移除后，数据结构自动删除，内存被回收。
- 常用于存储粉丝列表，比如 value 代表粉丝 ID，score 代表关注时间，从而可以按照时间排序
- 也可用于存储学生成绩，value 代表学生 ID，score 代表考试成绩，从而按照成绩排名
- 跳跃列表

	- zset 的内部排序功能通过「跳跃列表实现」
	- 类似于层级制，或者你可以想象为这张思维导图的样子
	- 一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。

- 有序集合为每个元素设置一个分数（score）作为排序依据

## 内存划分

### 数据

- 数据是最主要的部分
- 占用的内存会统计在 used_memory 中

### 进程本身运行需要的内存

- Redis 主进程本身运行肯定需要占用内存，如代码、常量池等等
- 这部分内存不是由 jemalloc 内存分配器分配，因此不会统计在 used_memory 中。
- 除了主进程外，Redis 创建的子进程运行也会占用内存，如 Redis 执行 AOF、RDB

### 缓冲内存

- 客户端缓冲区

	- 存储客户端连接的输入输出缓冲

- 复制积压缓冲区

	- 用于部分复制功能

- AOF 缓冲区

	- 进行 AOF 重写时，保存最近的写入命令

- 内存由 jemalloc 内存分配器分配，因此会统计在 used_memory 中。

### 内存碎片

- Redis 在分配、回收物理内存过程中产生的
- 内存碎片不会统计在 used_memory 中。

### 优化内存占用

- 利用 jemalloc（内存分配器）特性进行优化
- 使用整型/长整型
- 共享对象

	- 可以减少对象的创建，节省内存空间

- 避免过度设计
- 设置合理的数据回收策略

## 数据模型

### dictEntry

- 每个键值对都会有一个 dictEntry，里面存储了指向 Key 和 Value 的指针；
- next 指向下一个 dictEntry，与本 Key-Value 无关。

### Key

- Key 并不是直接以字符串存储，而是存储在 SDS 结构中
- SDS（Simple Dynamic String，简单动态字符串）

	- len

		- buf 已经使用的长度

	- free

		- buf 未使用的长度

	- buf[]

		- 字节数组，用来存储字符串
		- buf.length = free + len + 1

### redisObject

- Value 既不是直接以字符串存储，也不是像 Key 一样直接存储在 SDS 中，而是存储在 redisObject 中
- 不论 Value 是 5 种类型的哪一种，都是通过 redisObject 来存储的
- redisObject 中的 type 字段指明了 Value 对象的类型，ptr 字段则指向对象所在的地址
- 不过字符串对象虽然经过了 redisObject 的包装，但仍然需要通过 SDS 存储
- 底层构成及细节

	- type

		- 表示对象的类型，占4个 bit （比特）

	- encoding

		- 表示对象的内部编码，占4个 bit （比特）
		- string

			- int（8 字节）

				- 使用整数值实现的字符串对象
				- 当 int 数据不再是整数，或大小超过了 long 的范围时，自动转化为 raw。

			- embstr（<= 39字节）

				- 使用 embstr 编码的 SDS 实现的字符串对象
				- 只分配一次内存空间
				- 实现为「只读」

					- 对 embstr 对象进行修改时，都会先转化为 raw 再进行修改，所以只要是修改 embstr 对象，修改后的对象一定是 raw 的，无论是否达到了 39 个字节

			- raw（> 39 字节的字符串）

				- 使用 SDS 实现的字符串对象
				- 需要分配两次内存空间

			- 为啥以 39 作为区分？

				- redisObject 的长度是 16 字节
				- sds 的长度是 9+
				- jemalloc 正好可以分配 64 字节的内存单元

		- list

			- 压缩列表（ziplist）

				- 使用压缩列表实现的列表对象
				- 连续内存块
				- 使用满足条件

					- 列表中元素数量小于 512 个
					- 列表中所有字符串对象都不足 64 字节（便于统一分配每个节点的长度）

			- 双端链表（linkedlist）

				- 使用双端链表实现的列表对象

		- hash

			- 压缩列表（ziplist）

				- 使用压缩列表实现的列表对象
				- 使用满足条件

					- 哈希中元素数量小于 512 个
					- 哈希中所有键值对的键和值字符串长度都小于 64 字节

			- ht

				- 使用字典实现的哈希对象

		- set

			- intset

				- 使用整数集合实现的集合对象
				- 使用满足条件

					- 集合中元素数量小于 512 个
					- 集合中所有元素都是整数值

			- ht

				- 使用字典实现的集合对象

		- zset

			- 压缩列表（ziplist）

				- 使用压缩列表实现的列表对象
				- 使用满足条件

					- 有序集合中元素数量小于 128 个
					- 有序集合中所有成员长度都不足 64 字节

			- skiplist

				- 使用跳跃表和字典实现的有序集合对象

		- 编码转换在 Redis 写入数据时完成，且转换过程不可逆，只能从小内存编码向大内存编码转换。

	- lru

		- 对象最后一次被命令程序访问的时间

	- refcount

		- 记录的是对象被引用的次数，类型为整型
		- 主要用于对象的引用计数和内存回收
		- 创建新对象时，refcount 初始化为 1；当有新程序使用该对象时，refcount 加 1；当对象不再被一个新程序使用时，refcount 减 1；当 refcount 变为 0 时，对象占用的内存会被释放。
		- 被多次使用的对象（refcount > 1），称为共享对象，仅支持整数值的字符串对象

			- Redis 服务器在初始化时，会创建 10000个 字符串对象，值分别是 0~9999 的整数值；当 Redis 需要使用值为 0~9999 的字符串对象时，可以直接使用这些共享对象。

	- ptr

		- 指针，指向具体的数据

- 一个 redisObject 对象的大小为16字节（byte）

### 以后依靠 jemalloc（内存分配器）进行分配

## Redis 分区（配合集群使用）

### 分区的概念

- 分区就是将数据分割到多个 Redis 实例中的一个过程，因此每个实例仅仅包含部分键（key）

### 分区的优势

- 利用多台机器的内存构建一个更大数据库
- 可以在多核和多计算机之间弹性扩展计算能力，也可以在多计算机和网络适配器之间弹性扩展网络带宽

### 分区的劣势

- 不支持多个键的操作（可以曲线、间接实现）
- 不支持多个键的事务
- 不能使用单个大键对数据集进行分片
- 数据的处理会变得复杂，比如必须处理多个 RDB 和 AOF 文件
- 添加和删除节点也会变得复杂

### 分区基础、方式

- 范围分区
- 哈希分区（取余）
- 一致性哈希
- 带虚拟节点的一致性哈希分区（Redis 集群默认采用的方案）

### 分区不同的实现方式

- 客户端分区

	- 客户端直接选择正确节点读写指定键

- 代理辅助分区（Twemproxy）

	- 客户端通过 Redis 协议把请求发送给代理，而不是直接发送给真正的 Redis 实例服务器。
	- 代理根据请求根据配置分区策略发送到正确的 Redis 实例上，并返回给客户端。

- 查询路由

	- 把一个请求发送给一个随机的实例，这时实例会把该查询转发给正确的节点。

### 分区的使用

- Redis 如果作为可伸缩缓存服务器来使用，那么用一致性哈希比较简单
- Redis 被作为数据持久化服务器，需要提供节点和键值的固定映射，还有节点数目必须是固定的，不能改变。(使用集群解决问题)

## 集群方案

### Redis 高可用方案

- 持久化

	- 见左侧「Redis 持久化」

- 主从复制（即读写分离）

	- 作用

		- 数据冗余

			- 实现数据的热备份，属于持久化之外的一种数据冗余方式

		- 故障恢复

			- 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复
			- 也就是服务冗余的一种方式

		- 负载均衡

			- 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务

		- 高可用基石

			- 哨兵模式和集群能够实施的基础

	- 如何开启主从复制（只需要从「从节点」开启复制）？

		- 配置文件

			- 在从服务器的配置文件中加入：slaveof <masterip> <masterport>

		- 启动命令

			- redis-server启动命令后加入 --slaveof <masterip> <masterport>

		- 客户端命令

			- 通过客户端执行命令：slaveof <masterip> <masterport>，当前实例即为从节点

	- 主从复制实现原理

		- 连接建立阶段

			- 在主从节点之间建立连接，为数据同步做好准备。

				- 保存主节点信息
				- 建立 socket 连接
				- 发送 ping 命令
				- 身份验证
				- 发送从节点端口信息

		- 数据同步阶段

			- 从节点向主节点发送 psync 命令，开始同步。
			- 复制类型

				- 全量复制

					- 用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。

				- 部分复制

					- 用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。
					- 三个概念

						- 复制偏移量

							- 主节点和从节点分别维护一个复制偏移量（offset），代表的是主节点向从节点传递的字节数

						- 复制积压缓冲区

							- 由主节点维护的、固定长度的、先进先出（FIFO）队列，默认大小 1MB
							- 备份主节点最近发送给从节点的数据。
							- 无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。
							- bgsave 生成 RDB 文件、RDB 文件由主节点发往从节点、从节点清空老数据并载入 RDB 文件中的数据。

						- 服务器运行 ID

							- 主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个 runid 保存起来
							- 当断线重连时，从节点会将这个 runid 发送给主节点；主节点根据 runid 判断能否进行部分复制：

			- psync 复制命令

				- 从节点根据当前状态决定如何调用 psync

					- 如果没有执行过 slaveof 或者最近执行了 slaveof no one 命令，会向主节点发送「psync ? -1」命令，请求全量复制
					- 如果执行过 slaveof 命令，会发送「psync <runid> <offset>」命令请求部分复制

				- 主节点根据收到的 psync 命令以及当前服务器的状态决定执行全量复制还是部分复制

					- 如果 Redis 版本低于 2.8，直接执行全量复制
					- 如果版本符合部分复制的要求，并且接收到从节点发来的 runid 与当前自身 runid 相同，复制挤压缓冲区也包含从节点发送过来的 offset，则进行部分复制
					- 如果 runid 不同或者 offset 已经在复制挤压缓冲区中不完整，则发起全量复制

		- 命令传播阶段

			- 主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。
			- 主从心跳机制

				- PING

					- 每隔指定的时间，主节点会向从节点发送PING命令，这个 PING 命令的作用，主要是为了让从节点进行超时判断。

				- REPLCONF ACK

					- 从节点会向主节点发送 REPLCONF ACK 命令，频率是每秒 1 次

						- 实时监测主从节点网络状态
						- 检测命令丢失
						- 辅助保证从节点的数量和延迟

	- 主从复制、读写分离的普遍问题

		- 读写分离

			- 延迟与不一致
			- 数据过期

				- 惰性删除

					- 服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。

				- 定期删除

					- 服务器执行定时任务删除过期数据

				- Redis 3.2 版本以后，从节点在读取数据时，增加了对数据是否过期的判断

			- 故障切换

		- 主从复制

			-  复制超时

				- 主节点判断连接超时，其会释放相应从节点的连接，从而释放各种资源
				- 从节点判断连接超时，则可以及时重新建立连接，避免与主节点数据长期的不一致

			- 复制中断

				- 复制缓冲区溢出

		- 故障恢复无法自动化
		- 写操作无法负载均衡
		- 存储能力受到单机的限制

- 哨兵模式

	- 见下方「哨兵模式（Sentinel）」

- 集群

### 官方 redis-cluster 路由查询

- 优势及作用

	- 所有功能都集成在 redis cluster 中，路由分片、拓扑信息的存储、探活都在 redis cluster 中实现；各实例间通过 gossip 通信；这样的好处是简单，依赖的组件少
	- 数据分区（最核心的功能）

		- 将数据分散到多个节点，突破了 Redis 单机内存大小的限制，存储容量大大增加
		- 每个主节点都可以对外提供读服务和写服务，提高集群的响应能力
		- 关于 Redis 分区参考上面「Redis 分区（配合集群使用）」

	- 高可用

- 劣势：需要支持更大的规模时，由于使用 gossip 协议导致协议之间的通信消耗太大，redis cluster 不再合适；
- 
- 服务器端分片技术
- Redis 集群的键空间被分割为 16384 个槽（slot）， 集群的最大节点数量也是 16384 个。

### twemproxy 代理、nutcracker

- 原理：twemproxy 处于客户端和服务器的中间，将客户端发来的请求，进行一定的处理后（sharding），再转发给后端真正的redis服务器。
- 客户端不直接访问 redis 服务器，而是通过 twemproxy 代理中间件间接访问。降低了客户端直连后端服务器的连接数量，并且支持服务器集群水平扩展。
- 中间件做分片的技术
- 

	- 

		- 

### codis

- 特点

	- 分片算法：基于 slot hash 桶；
	- 分片实例之间相互独立，每组一个 master 实例和多个 slave；
	- 路由信息存放到第三方存储组件，如 zookeeper 或 etcd
	- 旁路组件探活

- 划分了 1024 个 slot， slots 信息在 proxy 层感知； redis 进程中维护本实例上的所有 ke y的一个 slot map；
- 图片可拖拽放大

### 哨兵模式（Sentinel）

- 解决主节点故障恢复的自动化问题，进一步提高系统的高可用性。在主从复制的基础上解决了「自动化的故障恢复」这个问题
- 原理：由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器以及这些主服务器下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。
- 至少需要 3 个实例，来保证自己的健壮性

	- 

		- 

- 功能及架构

	- 哨兵功能

		- 监控

			- 不断地检查主节点和从节点是否运作正常

		- 自动故障转移（核心功能）

			- 主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。

		- 配置提供者

			- 客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址。

		- 通知

			- 哨兵可以将故障转移的结果发送给客户端。

	- 架构

		- 哨兵节点

			- 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 redis 节点，不存储数据。

		- 数据节点

			- 主节点和从节点都是数据节点。

### 客户端分片，一致性哈希

- 关于一致性 Hash 算法，可以参考一下老四的这片文章《Java 十道由浅入深的笔面试题第四期》。http://www.glorze.com/1476.html

## 缓存

###  缓存模式

- Cache-Aside

	- 读操作

		- 程序接收数据查询的请求
		- 程序检查要查询的数据是否在缓存上

			- 如果存在，从缓存上查询出来
			- 如果不存在，从数据库中检索数据并存入缓存中

		- 程序返回要查询的数据

	- 更新操作

		- 使缓存失效

			- 当请求需要更新数据库数据的时候，缓存中的值需要被删除掉,下次数据读取的时候会存进缓存

		- 缓存更新

			- 在数据库更新的时候被更新

- Read-Through

	- 直接从缓存中读数据，该场景下是缓存去决定从哪查询数据。

- Write-Through

	- 所有的写操作都经过缓存，每次我们向缓存中写数据的时候，缓存会把数据持久化到对应的数据库中去，且这两个操作都在一个事务中完成。

### 缓存击穿

- 概念：请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。
- 问题：黑客拿数据库中不存在的字段值进行大量的请求导致服务宕机
- 解决方式

	- 缓存控制，定期设置过期时间
	- 哈希过滤

### 缓存穿透

- 概念：大量的请求同时查询一个 key 时，此时这个 key 正好失效了，就会导致大量的请求都打到数据库上面去
- 问题：造成数据库瞬间请求过载，压力陡增，服务宕机
- 解决方式

	- 请求线程加锁，或者数据库查询加锁
	- 数据返回记录之后作为缓存承载给其他请求

### 缓存雪崩

- 概念：缓存服务宕机，导致大量请求直接打进数据库造成服务宕机
- 问题：数据库由于请求量过大而崩溃 
- 解决方式

	- 缓存集群
	- 如果是微服务，可以设置网关限流
	- 使用缓存技术中的本地缓存（缓存在硬盘中）
	- 设置 Redis 持久化，服务重启之后自动加载数据缓存到 Redis 中

### 缓存预热

- 系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题
- 缓存预热设置方案

	- 直接写个缓存刷新页面，上线时手工操作下
	- 数据量不大，可以在项目启动的时候自动进行加载
	- 定时刷新缓存

### 缓存更新

- 除了 Redis 自有的缓存数据淘汰策略「数据淘汰策略（lru、随机、将要过期、不淘汰）」,还可以根据业务需求自定义缓存淘汰策略

	- 定时去清理过期的缓存

		- 维护大量缓存的 key 是比较麻烦的

	- 当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存

		- 每次用户请求过来都要判断缓存失效，逻辑相对比较复杂

### 缓存降级

- 当访问量剧增、服务出现问题（响应时间慢、不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务
- 最终目的是保证核心服务可用，即使是有损的
- 可以参考日志级别进行降级预案

### 热点数据集中失效

- 概念：缓存都有失效时间，那么作为热点数据失效的瞬间也会有大量的请求直接涌入到数据库
- 解决方式

	- 不同的热点数据设置不同的失效时间
	- 互斥锁

### 更新数据的时候先删除缓存还是先进行数据更新？

- 先删缓存再更新数据

	- 产生脏数据的概率较大，查询得到旧数据，多数不建议这样做

- 先更新数据再删除缓存

	- 脏数据产生概率低，但是会出现一致性异步问题，但是问题不大，数据更新之后更新缓存即可。多数情况建议选择此种方式

## Redis 锁

### 客户端可以使用同步机制

### 服务器端

- setnx

### 分布式锁

- 利用 setnx+expire 命令

	- SETNX 是 SET IF NOT Exists 的缩写，即 setnx key value，将 key 设置为 value，当键不存在时，才能成功，若键存在，什么也不做，成功返回 1，失败返回 0 。
	- 因为 setnx + expire 命令过程中不具有原子性，所以不推荐直接使用
	- 可以优化为使用 Lua 脚本将两个命令封装为一个操作进行使用，不过依然不推荐

-  使用 set key value [EX seconds][PX milliseconds][NX|XX] 命令 (推荐)

	- EX seconds: 设定过期时间，单位为秒
	- PX milliseconds: 设定过期时间，单位为毫秒
	- NX: 仅当key不存在时设置值
	- XX: 仅当key存在时设置值

- Redlock算法 与 Redisson 实现

	- 主要解决上一条锁在集群、多节点的情况下锁失效的问题
	- 获取当前时间
	- 发起请求，并设置超时时间，超时时间要小于锁的过期时间
	- 使用当前时间减掉开始获取锁的时间得到获取锁所使用的时间，这个时间要满足小于锁失败的时间并且实例当中超过一半的实例都获取到了锁才算成功
	- 如果锁获取失败，Redis 所有实例进行解锁，及时某些实例没有枷锁成功

## Redis 并发

### 大量数据插入使用管道（pipe）

## 数据淘汰策略（lru、随机、将要过期、不淘汰）

### volatile-lru

- 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰

### volatile-ttl

- 从已设置过期时间的数据集中挑选将要过期的数据淘汰

### volatile-random

- 从已设置过期时间的数据集中任意选择数据淘汰

### allkeys-lru

- 从数据集中挑选最近最少使用的数据淘汰

### allkeys-random

- 从数据集中任意选择数据淘汰

### no-enviction

- 禁止驱逐数据

## Redis 为什么快

### 基于内存

### 单线程节省上下文开销，Redis 是单进程单线程的，Redis利用「队列」技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。

###  I/O 多路复用

- 多路 - 指的是多个 socket 连接，也就是多个网络连接
复用 - 指的是复用一个线程。

	- 让单个线程高效的处理多个连接请求，从而减少网络请求浪费的时间
	- select
	- poll
	- epoll

		- 子主题 1

### 数据结构使用 hash 设计

## Redis 持久化

### RDB

- 快照存储持久化方式，具体就是将 Redis 某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为 dump.rdb，而在 Redis 服务器启动时，会重新加载 dump.rdb 文件的数据到内存当中恢复数据。

	- RDB 优劣势以及与 AOF 的比较

		- 与 AOF 方式相比，通过 rdb 文件恢复数据比较快。
		- rdb 文件非常紧凑，适合于数据备份。
		- 通过 RDB 进行数据备，由于使用子进程生成，所以对 Redis 服务器性能影响较小。
		- 如果服务器宕机的话，采用 RDB 的方式会造成某个时段内数据的丢失
		- 使用 save 命令会造成服务器阻塞，直接数据同步完成才能接收后续请求。
		- 由于 AOF 的优先级更高，因此当 AOF 开启时，Redis 会优先载入 AOF 文件来恢复数据
		- 只有当 AOF 关闭时，才会在 Redis 服务器启动时检测 RDB 文件，并自动载入，载入过程中 Redis 处于阻塞状态

	- 触发条件

		- 手动触发

			- save

				- 阻塞 Redis 服务器进程，直到 RDB 文件创建完毕为止，在 Redis 服务器阻塞期间，服务器不能处理任何命令请求。
				- 线上环境要杜绝 save 的使用

			- bgsave

				- 创建一个子进程，由子进程来负责创建 RDB 文件，父进程（即 Redis 主进程）则继续处理请求。

		- 自动触发

			- save m n

				- 在配置文件中通过「save m n」，指定当 m 秒内发生 n 次变化时，触发 bgsave 操作。

			- 在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行 bgsave 命令，并将 rdb 文件发送给从节点
			- 执行 shutdown 命令时，自动执行 rdb 持久化

### AOF（主流）

- 记录客户端对服务器的每一次写操作命令，并将这些写操作以 Redis 协议追加保存到以后缀为 aof 文件末尾，在 Redis 服务器重启时，会加载并运行 aof 文件的命令，以达到恢复数据的目的。

	- AOF 执行流程

		- 命令追加（append）

			- 将 Redis 的写命令追加到缓冲区 aof_buf，避免硬盘 IO 成为 Redis 负载的瓶颈。

		- 文件写入（write）、文件同步（sync）

			- 根据不同的同步策略将 aof_buf 中的内容同步到硬盘
			- 策略

				- no

					- 命令写入 aof_buf 后调用系统 write 操作，不对 AOF 文件做 fsync 同步；同步由操作系统负责，通常同步周期为 30 秒

				- always

					- 客户端的每一个写操作都保存到 aof 文件当中，这种策略很安全，但是每个写请注都有 IO 操作，所以也很慢。

				- everysec（默认配置）

					- 默认写入策略，每秒写入一次 aof 文件，因此，最多可能会丢失 1s 的数据。

		- 文件重写（rewrite）

			- 定期重写 AOF 文件，达到压缩的目的
			- 把 Redis 进程内的数据转化为写命令，同步到新的 AOF 文件，所以不会对旧的 AOF 文件进行任何读取、写入操作
			- 触发条件

				- 手动触发

					- 直接调用 bgrewriteaof 命令

				- 自动触发

					- 根据 auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage 参数，以及 aof_current_size 和 aof_base_size 状态确定触发时机

## redis-cli 命令相关

### info XXX

- info memory

	- 查看内存使用情况

		- used_memory

			- Redis 分配器分配的内存总量（单位是字节）

		- used_memory_rss

			- Redis 进程占据操作系统的内存（单位是字节）

		- mem_fragmentation_ratio

			- 内存碎片比率，该值是 used_memory_rss / used_memory 的比值。1.03 是比较正常的值

				- > 1

					- 内存碎片多，内存浪费严重
					- 考虑重启 redis 服务，在内存中对数据进行重排，减少内存碎片

				- < 1

					- 内存不足，部分数据使用了虚拟内存，访问速度可能会变得很慢

		- mem_allocator

			- Redis 使用的内存分配器，在编译时指定

				- libc 
				- jemalloc（默认）

					- 在减小内存碎片方面做的相对比较好
					- jemalloc 在 64 位系统中，将内存空间划分为小、大、巨大三个范围；每个范围内又划分了许多小的内存块单位；当 Redis 存储数据时，会选择大小最合适的内存块进行存储。

				- tcmalloc

- info 命令可以显示 redis 服务器的许多信息

	- 服务器基本信息

		- info server

	- CPU
	- 内存
	- 查看持久化相关状态

		- info Persistence

			- aof_enabled

				- AOF 是否开启

			- aof_last_rewrite_time_sec

				- 上次文件重写执行时间（s），用于发现文件重写是否耗时过长

			- aof_last_bgrewrite_status

				- 上次 bgrewrite 执行结果

			- aof_delayed_fsync

				- AOF 追加阻塞情况的统计

			- rdb_last_bgsave_status

				- 上次 bgsave 执行结果

			- rdb_last_bgsave_time_sec

				- 上次 bgsave 执行时间（s）

		- info stats

			- latest_fork_usec

				- 上次 fork 耗时

	- 客户端连接信息

### type key[XXX]

- 读取 RedisObject 的 type 字段获得对象 key 对应 Value 的类型

### object 相关命令

- object encoding key[XXX]

	- 查看对象 key 对应 Value 采用的编码方式

- object idletime key[XXX]

	- 显示当前 key 对应 Value 的空转时间（单位是秒）。空转时间就是该 Value 最后一次呗命令程序访问的时间.object idletime 命令不改变对象的 lru 值。

- object refcount key[XXX]

	- 查看 key 对应 value 的共享对象引用次数

### 发布与订阅

- SUBSCRIBE channel [channel …] 
-  UNSUBSCRIBE [channel [channel …]] 
-  PUBLISH channel message

### 事务相关命令

- discard

	- 取消事务，放弃执行事务块内的所有命令。
	- 如果正在使用 WATCH 命令监视某个或某些 key，那么取消所有监视，等同于执行命令 UNWATCH 

