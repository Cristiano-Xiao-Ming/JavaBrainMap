# MySQL 中的锁（详细版）

## MySQL 锁按照特性和设计分类

### 表级锁

- MyISAM 和 MEMORY 存储引擎采用，BDB 和 InnoDB 也支持表级锁。
- 开销小，加锁快
- 不会出现死锁（因为 MyISAM 总是一次性获得 SQL 语句需要的全部锁，所以不会出现死锁）
- 锁定粒度大（锁整张表），发生锁冲突概率高，并发度最低，基本都是串行化了。
- 适合以查询为主，辅以少量按索引条件更新数据的应用

### 行级锁

- InnoDB 默认采用
- 开销大，加锁慢
- 会出现死锁
- 锁定粒度小，发生锁冲突的概率最低，并发度自然就最高。
- 适合大量按索引条件并发更新少量数据不同数据，同时又有并发查询的应用

### 页面锁

- BDB 存储引擎采用，不过 BDB 已经被 InnoDB 取代，即将成为历史。
- 开销和加锁时间介于上面二者之间
- 会出现死锁
- 粒度和并发度也介于上述二者之间

## MyISAM 表级锁

### 表级锁的两种锁模式

- 表共享读锁

	- 不影响其他线程的读，但是不能写

- 表独占写锁

	- 其他线程的读锁、写锁都被阻塞

### 加表级锁的特性以及注意事项

- 一般不需要直接用「lLOCK TABLE」命令给 MyISAM 表显式加锁
- MyISAM 不支持锁升级，即当执行「LOCK TABLES」命令的时候只能访问显式加锁的这些表，不能访问没加锁的表
- MyISAM 锁表的时候需要别名加锁，否则没效

### MyISAM 的并发插入

- 虽然 MyISAM 读写串行，不过也支持查询和插入并发进行
- 系统变量：concurrent_insert

	- 当 concurrent_insert = 0，不允许并发插入
	- 当 concurrent_insert = 1，MySQL默认值设置，如果 MyISAM 表的中间被删除的行，允许在一个进程读表的同时，另一个进程从表尾插入记录
	- 当 concurrent_insert = 2，无限制插入

### MyISAM 的锁调度

- MySQL 认为写请求一般比读请求重要。MyISAM 默认写进程先获得锁。
- 调节 MyISAM 读进程优先获得锁

	- 通过指定启动参数「low-priority-updates」
	- 通过执行「SET LOW_PRIORITY_UPDATES=1」命令
	- 通过指定 INSERT、UPDATE、DELETE 语句的 LOW_PRIORITY 属性，降低写进程的优先级

## InnoDB 行级锁

### 事务及其 ACID 属性

- 原子性

	- 事务是一个原子操作单元，其对数据的修改，要么全部执行，要么全都不执行

- 一致性

	- 事务的开始和完成，所有相关的数据规则都必须应用于事务的修改，所有的内部数据结构（B树索引、双向链表等）都是正确的。

- 隔离性

	- 事务处理过程中的中间状态对外部是不可见的，保证事务不受外部并发操作的影响。

- 持久性

	- 事务完成之后，对于数据的修改是永久性的、持久化的。

### 并发事务的问题

- 更新丢失

  当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题—最后的更新覆盖了由其他事务所做的更新。

	- 防止更新丢失应该是应用的责任

- 脏读

  一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系

- 不可重复读

  一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变或某些记录已经被删除了

- 幻读

  一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据

### 事务的隔离级别

- 实现事务隔离的方式

	- 读取数据前对其加锁
	- MVCC（数据多版本并发控制）

		- 不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照，并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本。
		- 基于 undo log 使用 innodb 的两个隐藏字段 trx_id 和 roll_ptr 建立的一个数据请求时间点的一致性数据快照，只能查找创建时间小于当前事务 id 以及删除时间大鱼当前事务 id 的行
		- 在 RC 已提交读和 RR 可重复读两种隔离级别，对于 MVCC 来讲，RC 是每次查询时获取当前活跃事务的快照，后者 RR 是开启事务时就获取活跃事务快照

- 未提交读

	- 脏读、不可重复读、幻读均不能避免

- 已提交读

	- 可以避免脏读，不可重复度、幻读不能避免

- 可重复读

	- 可以避免脏读和不可重复度，幻读不能避免

- 可序列化、串行化

	- 相当于串行化操作，均可避免

### InnoDB 的行锁模式及加锁方式

- 行锁模式

	- 共享锁（S）

		- 允许一个事务去读一行，其他事务也可以读，但是不能写，即其他事务不能获得排他锁。

	- 排他锁（X）

		- 允许一个事务进行更新操作，其他事务既不能读取也不能更新数据，即其他事务不能获得共享读锁也不能获取排他写锁

	- 意向共享锁（IS）
	- 意向排他锁（IX）

- 加锁方式

	- 共享锁

		- SELECT * FROM table_name WHERE ... LOCK IN SHAREMODE;
		- 主要用于数据依存关系时来确认某行记录是否存在。不建议进行更新或者删除操作，因为其他事务也可以获得共享锁，容易造成死锁。

	- 排他锁

		- SELECT * FROM table_name WHERE ... FOR UPDATE;

### InnoDB 行锁的实现方式

- 通过给索引上的索引项加锁来实现，如果没有索引，会对隐藏的聚簇索引加锁。如果不通过索引条件检索数据，那么 InnoDB 会获取表锁。
- 索引项加锁（Record lock）
- 间隙锁（Gap lock）

	- 索引项之间的「间隙」
	- 记录之前的「间隙」
	- 记录之后的「间隙」

- 对记录及其前面的间隙加锁（Next-key lock）

	- 使用场景

		- 范围查询请求共享或者排他锁
		- 使用相等条件请求给不存在的记录加锁

	- 目的

		- 防止幻读
		- 满足恢复和复制的需要，即满足从 BINLOG 恢复数据 

- InnoDB 行锁实际使用注意事项

	- 在不通过索引条件查询时，InnoDB会锁定表中的所有记录
	- 由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。
	- 当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁
	- 即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB也会对所有记录加锁

### InnoDB 主动使用表锁的情景

- 事务需要更新大部分或全部数据，表又比较大
- 事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚
- 要将AUTOCOMMIT设为0，否则MySQL不会给表加锁

### InnoDB 中的死锁

- 发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。（干预的外部锁和表锁的情况除外）
- 避免死锁的常用的方法

	- 表访问约定顺序

		- 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会

	- 线程排序

		- 在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能

	- 处理数据就申请排他锁

		- 在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁，更新时再申请排他锁

	- 使用已提交读解决可重复读的死锁问题

		- 在可重复读的隔离级别下，如果两个线程同时对相同条件记录用 SELECT...FOR UPDATE 加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。

程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。

这种情况下，将隔离级别改成已提交读的隔离级别

	- 通过主键主键不可重复的特点解决已提交读的死锁问题

	  当隔离级别为已提交读时，如果两个线程都先执行 SELECT...FOR UPDATE，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第1个线程提交后，第2个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁！这时如果有第3个线程又来申请排他锁，也会出现死锁。
	  
	  对于这种情况，可以直接做插入操作，然后再捕获主键重异常，或者在遇到主键重错误时，总是执行 ROLLBACK 释放获得的排他锁。

