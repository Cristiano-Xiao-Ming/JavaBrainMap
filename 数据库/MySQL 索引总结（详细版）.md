# MySQL 索引总结（详细版）

## MySQL 存储引擎及对应索引

### InnoDB

- B+Tree
- B-Tree
- 哈希索引

	- 自适应哈希索引

### BDB

- 唯一哈希索引

### MyISAM

- R-Tree

### MEMORY

- 非唯一哈希索引（默认）
- B-Tree

### MERGE，也叫 MRG_MyISAM

### EXAMPLE

### NDB Cluster

### ARCHIVE

### CSV

### BLACKHOLE

### FEDERATED

### PERFORMANCE_SCHEMA

### TokuDB

### ScaleDB

## MySQL 支持的索引类型

### B-Tree（B 代表的平衡树而不是二叉树，B-Tree 索引并不是一颗二叉树）

- 支持的查询类型

	- 全关键字
	- 关键字范围
	- 关键字前缀

- 几种常用的使用场景

	- 全值匹配
	- 匹配值范围查询
	- 匹配最左前缀
	- 匹配列前缀
	- 精准或者匹配部分精准索引且匹配值范围查询匹配另外一列（覆盖索引）
	- 仅对索引进行查询匹配，即 select 索引列 from xx 这样的效率的更高
	- 匹配索引列为空一样会使用索引，类似于 「索引列 is null」的形式，优化器依然会进行索引优化查询
	- ICP 优化

		- 过滤操作下推操作，索引存在相关的列值，会直接在索引上进行条件过滤，然后回表查询，直接返回数据行指针，减少 I/O 操作。

- 缺点、限制，也算是几种索引失效的场景

	- 联合索引中如果不是按照索引的最左列开始查询，无法使用索引（col1,col2,col3），如果从 col2 或 col3 查询不会使用索引。
	- 联合索引中不能跳列查询，即必须满足最左原则。否则也不会使用索引。（col1,col2,col3），如果使用类似 col1=XX and col3=XX 查询不会使用索引。注意和上一条限制的区别。
	- 联合索引中如果某个列是范围查询，则后面的列索引失效。（col1,col2,col3）如果存在类似 col1=xx and col2 like ‘xx%’ and col3=xx，那么 col3 不会进行索引优化。
	- 以百分号「%」开头的 LIKE 查询不会使用 B-Tree 索引
	- 条件查询出现类型对应错误，会进行全表扫描，不会使用索引。例如：name=glorze，但是 name 是字符串类型，glorze 必须加引号。
	- 过滤性越高，MySQL 越容易使用索引。所以当 MySQL 认为全表扫描来得更快的时候不会使用索引。
	- 如果条件选择使用关键字「or」，即使前面的列有索引但是后面的列没有索引，涉及到的索引不会被使用。

### HASH 哈希索引

- 只有 MEMORY 存储引擎显示支持
- 优点

	- 索引只需要存储哈希值，索引结构紧凑，查找速度非常快

- 缺点

	- 因为不存储字段值，所以无法避免要读取行
	- 因为哈希无序，所以无法排序
	- 联合索引中不支持部分列索引查询，只能捆在在一起使用
	- 不支持范围查询，只能用于等值查询
	- 哈希冲突的问题

### 全文索引

### R-Tree，空间数据索引

- MyISAM
- 地理数据存储

### 分形树索引

- TokuDB

## 优点（主要根据 B-Tree 索引）

### 减少服务器扫描的数据量

### 避免排序和临时表

### 将随机 I/O 变为顺序 I/O

### B 树与 B+ 树的比较与总结

- B 树

	- 树内的每个节点都存储数据
	- 叶子节点之间无指针相邻
	- B 树的节点都存储数据，因此查询单条数据的时候，B 树的查询效率不固定，最好的情况是 O(1)。
	- 做单一数据查询的时候，使用 B 树平均性能更好。但是由于 B 树中各节点之间没有指针相邻，因此 B 树不适合做一些数据遍历操作。

- B+ 树

	- 数据只出现在叶子节点
	- 所有叶子节点增加了一个链指针
	- B+ 树的数据只出现在叶子节点上，因此在查询单条数据的时候，查询速度非常稳定。

		- 但平均性能并不如 B 树

	- B+ 树的叶子节点上有指针进行相连，因此在做数据遍历的时候，只需要对叶子节点进行遍历即可，这个特性使得 B+ 树非常适合做范围查询。

## 常用的索引设置策略

### 避免几种索引失效的场景

### 独立的列

- 索引的列不能是表达式的一部分
- 不能是函数的参数

### 前缀（后缀）索引和索引选择性

- 索引选择性

	- 定义：不重复的索引值和表的总记录数的比例。所以比例越高，索引的性能的就越高。
	- 唯一索引的索引选择性是 1，所以相对来讲，唯一索引的性能是最好的

- 如果某一字段类似于 http 链接那样长且在生产情景下需要添加索引，那么就可以考虑前缀索引。这样既能保证索引的高性能，又能避免性能开销过大。但是要注意前缀索引的合适选取长度。
- 前缀索引的缺点

	- 无法进行排序 order by
	- 无法进行分组 group by
	- 无法进行覆盖扫描

### 复合索引，多列索引

- 把 where 后面的常用列都建立单独索引其实不是一个优秀的解决方案。
- MySQL 中的有个「索引合并」的概念，对于多个单列索引进行的复杂查询会进行优化，从而也说明单列索引的性能在大多数时候失效
- 建立联合索引的时候需要考虑联合索引的合理顺序以及要注意联合索引的经常失效的场景。
- 合适的索引列顺序

	- 在不考虑排序和分组的情况下，如果用于优化 where 条件的查找，可以考虑将选择性最高的列放到索引最前列。

- 最左匹配原则，在遇到范围查询的时候，就会停止匹配。

### 聚簇索引

- 聚簇索引不是一种索引形式，而是一种数据存储形式，在 InnoDB 中，主键索引存储完整数据行
- 优点

	- 相关数据保存在一起，数据访问更快
	- 使用覆盖索引扫描的查询可以直接使用叶子节点的值

- 缺点

	- 虽然将数据放在内存中会是速度加快，但是也增加了存储开销，所以将数据全部放入内存也就意味着聚簇索引失去了意义
	- 插入速度依赖于插入顺序
	- 更新聚簇索引列的代价、开销会变得更高
	- 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂的问题。

		- 平衡树的数据结构，如果插入不规则的数据，会导致当前节点所属的页满，然后进行页分裂操作，容纳新增的数据，这样的话会极大的影响性能。
		- 这也是建议 InnoDB 建议逐渐设置为自增的原因，而尽量不要使用 UUID 或者无规则的字符串作为主键。

	- 可能导致全表扫描变慢，尤其是行比较稀疏或者存储不连续

### 覆盖索引（只有 B-Tree 支持）

- 索引包含所有需要查询的字段的值，就称之为「覆盖索引」
- 优点

	- 不需要回表查询，减少数据访问量。
	- 简单的范围查询可以使用顺序的索引访问

### 使用索引扫描做排序

- 两种排序

	- order by 排序操作
	- 索引顺序扫描

- 在索引设计的时候需要设置某一索引，让其尽量既能满足手动排序，又能做查找，设计就算是比较好的。要求索引的列顺序和 order by 顺序一致。

### 避免冗余和重复索引

## 索引（B+树）

索引是一种数据结构，用于加快mysql获取数据的速度；

常见索引模型：哈希表、有序数组、搜索树。

索引类型：主键索引（存储整行数据）、非主键索引（主键的值，需要回表两次查询）

### 数据结构角度

- B+ 树索引（查询性能高、IO 次数少、范围查询简便）

	- 每一个父节点的元素都出现在子节点中，是子节点的最大或最小元素。
	- 非叶子节点不保存数据，只保存关键字用作索引，所有数据都保存在叶子节点中。
	- 内部节点不保存数据，所以能在内存中存放更多索引，增加缓存命中率。

- 哈希索引（单行查询快）

  哈希索引基于哈希表实现，只有精确匹配索引的所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。
  
  作者：counterxing
  链接：https://www.zhihu.com/question/67094336/answer/250034118
  来源：知乎
  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

	- 无法用于排序
	- 仅支持 < = > 以及 IN 操作
	- 哈希冲突比较多的话，维护代价高
	- 不能避免全表扫描
	- 不支持部分索引列匹配查找

- FULLTEXT 全文索引（MyISAM 和 InnoDB）

	- 更建议使用 Lucene、Solar 等

- R-Tree索引

	- 解决空间数据检索的问题。

### 物理存储角度

- 聚簇索引（Cluster Index）

	- InnoDB 存储引擎的数据组织方式就是聚簇索引表，完整的记录，存储在主键索引中，通过主键索引，就可以获取记录所有的列。

- 非聚簇索引

	- MyISAM 就是非聚簇索引
	- 叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

### 逻辑角度

- 主键索引，特殊的唯一索引，不允许为空，整行索引
- 普通索引、单列索引
- 多列索引、复合索引（遵循最左前缀原则）
- 唯一索引或者非唯一索引
- 空间索引（只存在 MYISAM 存储引擎中）

### 设计索引的原则

- 搜索的索引列，出现在 where 子句中的列
- 使用唯一索引
- 使用短索引，对字符串列进行索引，去字符串的前 N 个字符
- 利用最左前缀，可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。
- 不要过度索引，占磁盘空间，降低写操作性能。
- InnoDB 尽量自己指定主键

### 面试常问的「主键索引、唯一索引和普通索引的区别」

- 主键索引

	- 主键索引只要搜索ID这个B+Tree即可拿到数据。
	- 不允许空值

- 唯一索引

	- 必须唯一，允许空值

- 普通索引

	- 普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)

	  回到主键索引树搜索的过程，称为回表

