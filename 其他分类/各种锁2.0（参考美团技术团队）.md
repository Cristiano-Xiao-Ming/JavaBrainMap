# 各种锁2.0（参考美团技术团队）

## MySQL 相关锁概念（MVCC）

### 乐观锁、悲观锁

- 乐观锁

	- 定义

		- 在关系数据库管理系统里，乐观并发控制（又名“乐观锁”,缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。

	- 流程

		- 数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。

	- 优缺点

		- 乐观并发控制相信事务之间的数据竞争(data race)的概率较小
		- 不会产生任何锁和死锁
		- 两个事务都读取了数据库的某一行，经过修改以后写回数据库会有问题

- 悲观锁

	- 定义

		- 在关系数据库管理系统里，悲观并发控制（又名“悲观锁”,缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。

	- 流程

		- 在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。

	- 优缺点

		- “先取锁再访问”的保守策略
		- 为数据处理的安全提供了保证
		- 在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；
		- 在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载
		- 会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理行数

### 共享锁、排他锁

- 共享锁

	- 其他事务可以读，但不能写。

- 排他锁

	- 其他事务不能读取，也不能写。

### GAP锁、间隙锁

- 间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。

### Next-Key锁

- 锁定一个范围，并且锁定记录本身。

### 2PL锁

### 粒度锁

- 行锁

	- 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

- 表锁

	- 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

- 页锁

	- 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

## Java 中主流锁

### 多个线程能不能共享一把锁？

- 共享锁

	- 允许多个线程同时获取锁，并发访问，共享资源。AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。实现如：CountDownLatch（门阀）、Semaphor（信号量）、ReadWriteLock（读写锁）

- 排他锁、独占锁

	- 每次只能有一个线程能持有锁，ReentrantLock就是以独占方式实现的互斥锁。

### 多个线程竞争锁是是否需要排队？

- 公平锁

	- 每个线程抢占锁的顺序为先后调用 lock 方法的顺序依次获取锁。换句话说，先对锁进行获取的请求一定被先满足，那么这个锁是公平的。在 ReentrantLock 中会体现线程具有不连续性，偏线性化。

- 非公平锁（先尝试插队，插队失败再排队）

	- 每个线程抢占锁的顺序不定，谁运气好，谁就获取到锁，和调用 lock 方法的先后顺序无关。在 ReentrantLock 中会体现一个线程连续获取锁的情况比较多，插队现象严重。

### 多个线程竞争同步资源的流程细节

- 无锁

	- 不锁住资源，多个线程中只有一个能修改资源成功，其它线程会重试。

- 偏向锁

	- 同一个线程执行同步资源时自动获取资源

- 轻量级锁

	- 多个线程竞争同步资源时，没有获取资源的线程自旋等待锁释放。

- 重量级锁（Synchronized）

	- 多个线程竞争同步资源时，没有获取资源的线程阻塞等待唤醒
	- 无论你的同步块是正常还是异常退出的，里面的线程都会释放锁

### 锁住同步资源失败的话，线程是否阻塞

- 直接阻塞
- 自旋锁

  通俗：当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。

	- 线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。

- 适应性自旋锁

	- 自旋的时间不再是固定的， 而是由前一次在同一个锁上的自旋时间以及锁拥有者的状态来决定。

- 特殊的自旋锁：读写锁

	- 只要没有写模式下的加锁，任意线程都可以进行读模式下的加锁；
	- 只有读写锁处于不加锁状态时，才能进行写模式下的加锁；

### 线程要不要锁住同步资源

- 悲观锁

	- Lock 的实现类
	- Synchronized

- 乐观锁（CAS）

	- 认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作

### 一个线程能不能多次获取锁？

- 可重入锁、可递归锁
- 不可重入锁、非递归锁

### 单一时刻线程拥有锁的顺序行为

- 互斥锁

	- 指在某一时刻指允许一个进程运行其中的程序片，具有排他性和唯一性。

- 同步锁

	- 在互斥的基础上，实现进程之间的有序访问。假设现有线程A和线程B，线程A需要往缓冲区写数据，线程B需要从缓冲区读数据，但他们之间存在一种制约关系，即当线程A写的时候，B不能来拿数据；B在拿数据的时候A不能往缓冲区写，也就是说，只有当A写完数据（或B取走数据），B才能来读数据（或A才能往里写数据）。这种关系就是一种线程的同步关系。

### 死锁

- 两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。 此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

### 分段锁（ConcurrentHashMap）

- 首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

