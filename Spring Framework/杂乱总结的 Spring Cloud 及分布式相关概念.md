# 杂乱总结的 Spring Cloud 及分布式相关概念

## Feign

### FeignClient注解参数

- name

	- value 的别名

- value

	- name 的别名

- serviceId

	- 同 value 和 name,现在已经被弃用

- contextId

	- @FeignClient 在 Greenwich.SR1 版本之后增加一个属性值 contextId，
之前的版本如果有存在两个 name 属性相同 @FeignClient 对象，不会报错，但是升级后，会将相同 name 属性的实例对象认为是同一个 Bean ，从而抛出如下异常：「The bean 'icc-authority.FeignClientSpecification', defined in null, could not be registered. A bean with that name has already been defined in null and overriding is disabled.」，解决方案就是在 @FeignClient 注解里增加 contextId 值将为 bean id。
	- Spring Cloud Feign 支持的核心概念是可以指定所要调用的服务(即指定服务名：spring.application.name)。一个消费者应用可能有多个 feign 客户端组件构成为一个集合，各个组件按需调用远程服务。该组件集合有一个名称，也可以使用 @FeignClient 注解的 contextId 属性自定义。
	- Spring Cloud 使用 FeignClientsConfiguration 按需为每个命名客户端创建一个新集合作作为 ApplicationContext ，包含了a feign.Decoder, a feign.Encoder, a feign.Contract，可以使用 @FeignClient 注解的 contextId 属性重写该集合的名称。

- qualifier
- url
- decode404
- configuration
- fallback
- fallbackFactory
- path
- primary

## 分布式事务

### 事务的基本知识

- 原子、一致、隔离、持久
- 脏读（事务A读取到了事务B未提交的数据）、幻读（事务A读取某条数据两次，第二次被事务B进行了插入、删除、更新等操作）、不可重复读（事务A读取某条数据两次却得到不同的结果）
- 读未提交、读已提交、重复读（MySQL 默认）、序列化
- CAP 理论

	- Consistency 一致性 同一数据的多个副本是否实时相同。
	- Availability 可用性 一定时间内系统返回一个明确的结果则称为该系统可用。
	- Partition tolerance 分区容错性 将同一服务分布在多个系统中，从而保证某一个系统宕机，仍然有其他系统提供相同的服务。

- BASE 理论

	- 通过牺牲一致性来换取系统的可用性和分区容错性
	- Basic Available 基本可用
	- Soft State：柔性状态 同一数据的不同副本的状态，可以不需要实时一致。
	- Eventual Consisstency：最终一致性 同一数据的不同副本的状态，可以不需要实时一致，但一定要保证经过一定时间后仍然是一致的。

- 分布式事务三种场景

	- 跨数据库分布式事务
	- 跨服务分布式事务
	- 混合式分布式事务

- 两阶段提交（XA）

	- 核心角色

		- RM - 资源管理器
		- TM - 事务管理器
		- AP - 应用程序
		- CRMs - 跨服务的事务的传播

	- 投票阶段

		- TM 记录事务开始日志，并询问各个 RM 是否可以执行提交准备操作。
		- RM 收到指令后，评估自己的状态，尝试执行本地事务的预备操作：预留资源，为资源加锁、执行操作等，但是并不提交事务，并等待 TM 的后续指令

	- 提交执行

		- 如果所有 RM 在上一个步骤都返回执行成功

			- TM 记录事务 commit 日志，并向所有 RM 发起事务提交指令。
			- RM 收到指令后，提交事务，释放资源，并向 TM 响应「提交完成」。
			- 如果 TM 收到所有 RM 的响应，则记录事务结束日志。

		- 如果有 RM 在上一个步骤中返回执行失败或者超时没有应答，即事务失败处理

			- 记录事务 abort 日志，向所有 RM 发送事务回滚指令。
			- RM 收到指令后，回滚事务，释放资源，并向 TM 响应回滚完成。
			- 如果 TM 收到所有 RM 的响应，则记录事务结束日志。

	- 产生的问题

		- TM 事务管理器的单点故障
		- RM 资源管理器一直持有资源所，过多的 RM 导致系统吞吐量下降
		- 脑裂

			- TM 在第二阶段通知 RM 提交事务的时候突然宕机，恢复的时候无法重新协调事务的一致性

- 三阶段提交

	- 主要解决两阶段提交的单点故障问题
	- 基本不用

### 全局消息

### TCC（两阶段提交）

- 补偿型事务，要求应用提供下面三个接口。的核心思想是通过对资源的预留（提供中间态），尽早释放对资源的加锁，如果事务可以提交，则完成对预留资源的确认，如果事务要回滚，则释放预留的资源。

- Try

	- 完成业务检查（一致性）、预留业务资源（准隔离性）

- Commit

	- 如果 try 阶段所有业务资源都预留成功，则执行 confirm 操作
	- 不做任何业务检查，仅仅使用预留的资源执行业务操作，如果失败会一直重试。

- Cancel

	- 如果 try 阶段所有业务资源都预留失败，则执行 cancel 操作
	- 取消执行业务操作，释放预留的资源，如果失败会一直重试。

- TCC 模式中，事务的发起者和参与者都需要记录事务日志，事务的发起者需要记录全局事务和各个分支事务的状态和信息；事务的参与者需要记录分支事务的状态。
- 需要遵循三个策略

	- 允许空回滚
	- 保持幂等性
	- 防止资源悬挂

### Sega

- 补偿事务，但是它没有 try 阶段，而是把分布式事务看作一组本地事务构成的事务链。即按顺序执行事务
- 不保证隔离性，与 TCC 一样遵循三个策略，适合长事务流程场景

### 队列

- 难点在于解决本地事务执行和消息发送的一致性：两者要同时执行成功或者同时取消执行。
- 事务消息

	- 事务消息和普通消息的区别在于事务消息发送成功后，处于 prepared 状态，不能被订阅者消费，等到事务消息的状态更改为可消费状态后，下游订阅者才可以监听到次消息。
	- 事务发起者预先发送一个事务消息。
	- MQ 系统收到事务消息后，将消息持久化，消息的状态是「待发送」，并给发送者一个 ACK 消息。
	- 事务发起者如果没有收到 ACK 消息，则取消本地事务的执行；如果收到了 ACK 消息，则执行本地事务，并给 MQ 系统再发送一个消息，通知本地事务的执行情况。
	- MQ 系统收到消息通知后，根据本地事务的执行情况更改事务消息的状态，如果成功执行，则将消息更改为「可消费」并择机下发给订阅者；如果事务执行失败，则删除该事务消息。
	- 本地事务执行完毕后，发给 MQ 的通知消息有可能丢失了。所以支持事务消息的 MQ 系统有一个定时扫描逻辑，扫描出状态仍然是“待发送”状态的消息，并向消息的发送方发起询问，询问这条事务消息的最终状态如何并根据结果更新事务消息的状态。因此事务的发起方需要给 MQ 系统提供一个事务消息状态查询接口。
	- 如果事务消息的状态是「可发送」，则 MQ 系统向下游参与者推送消息，推送失败会不停重试。
	- 下游参与者收到消息后，执行本地事务，本地事务如果执行成功，则给 MQ 系统发送 ACK 消息；如果执行失败，则不发送 ACK 消息，MQ 系统会持续推送给消息。

- 普通消息加数据库维护

	- 核心思想是事务的发起方维护一个本地消息表，业务执行和本地消息表的执行处在同一个本地事务中。业务执行成功，则同时记录一条「待发送」状态的消息到本地消息表中。
	- 启动一个定时任务定时扫描本地消息表中状态为“待发送”的记录，并将其发送到 MQ 系统中，如果发送失败或者超时，则一直发送，直到发送成功后，从本地消息表中删除该记录。后续的消费订阅流程则与基于事务消息的模式一样。

- 最大努力通知型分布式事务

	- 本质是通过引入定期校验机制来对最终一致性做兜底，对业务侵入性较低、对 MQ 系统要求较低，实现比较简单，适合于对最终一致性敏感度比较低、业务链路较短的场景

## 分布式锁

### 分布式锁的特点

- 互斥性： 同一时刻只能有一个线程持有锁
- 可重入性： 同一节点上的同一个线程如果获取了锁之后能够再次获取锁
- 锁超时：和J.U.C中的锁一样支持锁超时，防止死锁
- 高性能和高可用： 加锁和解锁需要高效，同时也需要保证高可用，防止分布式锁失效
- 具备阻塞和非阻塞性：能够及时从阻塞状态中被唤醒

### 实现方式

- 基于数据库

	- 使用表的唯一约束特性
	- 创建一张锁表，表中设计主键、锁定的方法名、客户端唯一编号等核心字段，加锁的时候可以根据服务器 mac 地址与线程编号唯一来确定，释放锁的时候删除记录即可
	- 性能开销大

- 基于Redis

	- 利用 setnx+expire 命令

		- SETNX 是 SET IF NOT Exists 的缩写，即 setnx key value，将 key 设置为 value，当键不存在时，才能成功，若键存在，什么也不做，成功返回 1，失败返回 0 。
		- 因为 setnx + expire 命令过程中不具有原子性，所以不推荐直接使用
		- 可以优化为使用 Lua 脚本将两个命令封装为一个操作进行使用，不过依然不推荐

	-  使用 set key value [EX seconds][PX milliseconds][NX|XX] 命令 (推荐)

		- EX seconds: 设定过期时间，单位为秒
		- PX milliseconds: 设定过期时间，单位为毫秒
		- NX: 仅当key不存在时设置值
		- XX: 仅当key存在时设置值

	- Redlock算法 与 Redisson 实现

		- 主要解决上一条锁在集群、多节点的情况下锁失效的问题
		- 获取当前时间
		- 发起请求，并设置超时时间，超时时间要小于锁的过期时间
		- 使用当前时间减掉开始获取锁的时间得到获取锁所使用的时间，这个时间要满足小于锁失败的时间并且实例当中超过一半的实例都获取到了锁才算成功
		- 如果锁获取失败，Redis 所有实例进行解锁，及时某些实例没有枷锁成功

	- 运维成本高，操作不好容易死锁

- 基于 ZooKeeper

	- 临时有序节点可以实现的分布式锁
	- 每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。
	- 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。

